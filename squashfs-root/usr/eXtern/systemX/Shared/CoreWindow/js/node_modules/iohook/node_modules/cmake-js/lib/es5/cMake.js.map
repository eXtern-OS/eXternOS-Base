{"version":3,"names":[],"mappings":"","sources":["cMake.js"],"sourcesContent":["\"use strict\";\r\nlet splitargs = require(\"splitargs\");\r\nlet which = require(\"which\");\r\nlet Promise = require(\"bluebird\");\r\nlet fs = require(\"fs-extra\");\r\nlet path = require(\"path\");\r\nlet _ = require(\"lodash\");\r\nlet environment = require(\"./environment\");\r\nlet Dist = require(\"./dist\");\r\nlet CMLog = require(\"./cmLog\");\r\nlet vsDetect = require(\"./vsDetect\");\r\nlet TargetOptions = require(\"./targetOptions\");\r\nlet processHelpers = require(\"./processHelpers\");\r\nlet locateNAN = require(\"./locateNAN\");\r\nlet npmConfigData = require(\"rc\")(\"npm\");\r\nlet async = Promise.coroutine;\r\nlet Toolset = require(\"./toolset\");\r\n\r\nfunction CMake(options) {\r\n    this.options = options || {};\r\n    this.log = new CMLog(this.options);\r\n    this.dist = new Dist(this.options);\r\n    this.projectRoot = path.resolve(this.options.directory || process.cwd());\r\n    this.workDir = path.resolve(this.options.out || path.join(this.projectRoot, \"build\"));\r\n    this.config = this.options.debug ? \"Debug\" : \"Release\";\r\n    this.buildDir = path.join(this.workDir, this.config);\r\n    this._isAvailable = null;\r\n    this.targetOptions = new TargetOptions(this.options);\r\n    this.toolset = new Toolset(this.options);\r\n    this.cMakeOptions = this.options.cMakeOptions || {};\r\n    this.silent = !!options.silent;\r\n}\r\n\r\nObject.defineProperties(CMake.prototype, {\r\n    path: {\r\n        get: function () {\r\n            return this.options.cmakePath || \"cmake\";\r\n        }\r\n    },\r\n    isAvailable: {\r\n        get: function () {\r\n            if (this._isAvailable === null) {\r\n                this._isAvailable = CMake.isAvailable(this.options);\r\n            }\r\n            return this._isAvailable;\r\n        }\r\n    }\r\n});\r\n\r\nCMake.isAvailable = function (options) {\r\n    options = options || {};\r\n    try {\r\n        if (options.cmakePath) {\r\n            let stat = fs.lstatSync(options.cmakePath);\r\n            return !stat.isDirectory();\r\n        }\r\n        else {\r\n            which.sync(\"cmake\");\r\n            return true;\r\n        }\r\n    }\r\n    catch (e) {\r\n        _.noop(e);\r\n    }\r\n    return false;\r\n};\r\n\r\nCMake.getGenerators = async(function* (options) {\r\n    let arch = \" [arch]\";\r\n    options = options || {};\r\n    let gens = [];\r\n    if (CMake.isAvailable(options)) {\r\n        // try parsing machine-readable capabilities (available since CMake 3.7)\r\n        try {\r\n            let stdout = yield processHelpers.exec((options.cmakePath || \"cmake\") + \" -E capabilities\");\r\n            let capabilities = JSON.parse(stdout);\r\n            return capabilities.generators.map(x => x.name);\r\n        } catch (error) {\r\n            this.log.verbose(\"TOOL\", \"Failed to query CMake capabilities (CMake is probably older than 3.7)\");\r\n        }\r\n\r\n        // fall back to parsing help text\r\n        let stdout = yield processHelpers.exec((options.cmakePath || \"cmake\") + \" --help\");\r\n        let hasCr = stdout.includes(\"\\r\\n\");\r\n        let output = hasCr ? stdout.split(\"\\r\\n\") : stdout.split(\"\\n\");\r\n        let on = false;\r\n        output.forEach(function (line, i) {\r\n            if (on) {\r\n                let parts = line.split(\"=\");\r\n                if ((parts.length === 2 && parts[0].trim()) ||\r\n                    (parts.length === 1 && i !== output.length - 1 && output[i + 1].trim()[0] === \"=\")) {\r\n                    let gen = parts[0].trim();\r\n                    if (_.endsWith(gen, arch)) {\r\n                        gen = gen.substr(0, gen.length - arch.length);\r\n                    }\r\n                    gens.push(gen);\r\n                }\r\n            }\r\n            if (line.trim() === \"Generators\") {\r\n                on = true;\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        throw new Error(\"CMake is not installed. Install CMake.\");\r\n    }\r\n    return gens;\r\n});\r\n\r\nCMake.prototype.getGenerators = function () {\r\n    return CMake.getGenerators(this.options);\r\n};\r\n\r\nCMake.prototype.verifyIfAvailable = function () {\r\n    if (!this.isAvailable) {\r\n        throw new Error(\"CMake executable is not found. Please use your system's package manager to install it, or you can get installers from there: http://cmake.org.\");\r\n    }\r\n};\r\n\r\nCMake.prototype.getConfigureCommand = async(function* () {\r\n    // Create command:\r\n    let command = this.path;\r\n    command += \" \\\"\" + this.projectRoot + \"\\\" --no-warn-unused-cli\";\r\n\r\n    let D = [];\r\n\r\n    // CMake.js watermark\r\n    D.push({\"CMAKE_JS_VERSION\": environment.moduleVersion});\r\n\r\n    // Build configuration:\r\n    D.push({\"CMAKE_BUILD_TYPE\": this.config});\r\n    if (environment.isWin) {\r\n\t\tD.push({\"CMAKE_RUNTIME_OUTPUT_DIRECTORY\": this.workDir});\r\n\t}\r\n\telse {\r\n\t\tD.push({\"CMAKE_LIBRARY_OUTPUT_DIRECTORY\": this.buildDir});\r\n\t}\r\n\r\n    // Include and lib:\r\n    let incPaths;\r\n    if (this.dist.headerOnly) {\r\n        incPaths = [path.join(this.dist.internalPath, \"/include/node\")];\r\n    }\r\n    else {\r\n        let nodeH = path.join(this.dist.internalPath, \"/src\");\r\n        let v8H = path.join(this.dist.internalPath, \"/deps/v8/include\");\r\n        let uvH = path.join(this.dist.internalPath, \"/deps/uv/include\");\r\n        incPaths = [nodeH, v8H, uvH];\r\n    }\r\n\r\n    // NAN\r\n    let nanH = yield locateNAN(this.projectRoot);\r\n    if (nanH) {\r\n        incPaths.push(nanH);\r\n    }\r\n\r\n    // Includes:\r\n    D.push({\"CMAKE_JS_INC\": incPaths.join(\";\")});\r\n\r\n    // Runtime:\r\n    D.push({\"NODE_RUNTIME\": this.targetOptions.runtime});\r\n    D.push({\"NODE_RUNTIMEVERSION\": this.targetOptions.runtimeVersion});\r\n    D.push({\"NODE_ARCH\": this.targetOptions.arch});\r\n\r\n    if (environment.isWin) {\r\n        // Win\r\n        let libs = this.dist.winLibs;\r\n        if (libs.length) {\r\n            D.push({\"CMAKE_JS_LIB\": libs.join(\";\")});\r\n        }\r\n    }\r\n\r\n    // Custom options\r\n    for (let k of _.keys(this.cMakeOptions)) {\r\n        D.push({[k]: this.cMakeOptions[k]});\r\n    }\r\n\r\n    // Toolset:\r\n    yield this.toolset.initialize(false);\r\n\r\n    if (this.toolset.generator) {\r\n        command += \" -G\\\"\" + this.toolset.generator + \"\\\"\";\r\n    }\r\n    if (this.toolset.toolset) {\r\n        command += \" -T\\\"\" + this.toolset.toolset + \"\\\"\";\r\n    }\r\n    if (this.toolset.cppCompilerPath) {\r\n        D.push({\"CMAKE_CXX_COMPILER\": this.toolset.cppCompilerPath});\r\n    }\r\n    if (this.toolset.cCompilerPath) {\r\n        D.push({\"CMAKE_C_COMPILER\": this.toolset.cCompilerPath});\r\n    }\r\n    if (this.toolset.compilerFlags.length) {\r\n        D.push({\"CMAKE_CXX_FLAGS\": this.toolset.compilerFlags.join(\" \")});\r\n    }\r\n    if (this.toolset.linkerFlags.length) {\r\n        D.push({\"CMAKE_SHARED_LINKER_FLAGS\": this.toolset.linkerFlags.join(\" \")});\r\n    }\r\n    if (this.toolset.makePath) {\r\n        D.push({\"CMAKE_MAKE_PROGRAM\": this.toolset.makePath});\r\n    }\r\n\r\n    // Load NPM config\r\n    for (let key of _.keys(npmConfigData)) {\r\n        if (_.startsWith(key, \"cmake_\")) {\r\n            let s = {};\r\n            let sk = key.substr(6);\r\n            if (sk) {\r\n                s[sk] = npmConfigData[key];\r\n                if (s[sk]) {\r\n                    D.push(s);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    command += \" \" +\r\n        D.map(function (p) {\r\n            return \"-D\" + _.keys(p)[0] + \"=\\\"\" + _.values(p)[0] + \"\\\"\";\r\n        }).join(\" \");\r\n\r\n    return command;\r\n});\r\n\r\nCMake.prototype.configure = async(function* () {\r\n    this.verifyIfAvailable();\r\n\r\n    this.log.info(\"CMD\", \"CONFIGURE\");\r\n    let listPath = path.join(this.projectRoot, \"CMakeLists.txt\");\r\n    let command = yield this.getConfigureCommand();\r\n\r\n    try {\r\n        yield fs.lstat(listPath);\r\n    }\r\n    catch (e) {\r\n        throw new Error(\"'\" + listPath + \"' not found.\");\r\n    }\r\n\r\n    try {\r\n        yield fs.ensureDir(this.workDir);\r\n    }\r\n    catch (e) {\r\n        _.noop(e);\r\n    }\r\n\r\n    let cwd = process.cwd();\r\n    process.chdir(this.workDir);\r\n    try {\r\n        yield this._run(command);\r\n    }\r\n    finally {\r\n        process.chdir(cwd);\r\n    }\r\n});\r\n\r\nCMake.prototype.ensureConfigured = async(function* () {\r\n    try {\r\n        yield fs.lstat(path.join(this.workDir, \"CMakeCache.txt\"));\r\n    }\r\n    catch (e) {\r\n        _.noop(e);\r\n        yield this.configure();\r\n    }\r\n});\r\n\r\nCMake.prototype.getBuildCommand = function() {\r\n    var command = this.path + \" --build \\\"\" + this.workDir + \"\\\" --config \" + this.config;\r\n    if (this.options.target) {\r\n        command += \" --target \" + this.options.target;\r\n    }\r\n    return Promise.resolve(command);\r\n};\r\n\r\nCMake.prototype.build = async(function* () {\r\n    this.verifyIfAvailable();\r\n\r\n    yield this.ensureConfigured();\r\n    let buildCommand = yield this.getBuildCommand();\r\n    this.log.info(\"CMD\", \"BUILD\");\r\n    yield this._run(buildCommand);\r\n});\r\n\r\nCMake.prototype.getCleanCommand = function () {\r\n    return this.path + \" -E remove_directory \\\"\" + this.workDir + \"\\\"\";\r\n};\r\n\r\nCMake.prototype.clean = function () {\r\n    this.verifyIfAvailable();\r\n\r\n    this.log.info(\"CMD\", \"CLEAN\");\r\n    return this._run(this.getCleanCommand());\r\n};\r\n\r\nCMake.prototype.reconfigure = async(function* () {\r\n    yield this.clean();\r\n    yield this.configure();\r\n});\r\n\r\nCMake.prototype.rebuild = async(function* () {\r\n    yield this.clean();\r\n    yield this.build();\r\n});\r\n\r\nCMake.prototype.compile = async(function* () {\r\n    try {\r\n        yield this.build();\r\n    }\r\n    catch (e) {\r\n        _.noop(e);\r\n        this.log.info(\"REP\", \"Build has been failed, trying to do a full rebuild.\");\r\n        yield this.rebuild();\r\n    }\r\n});\r\n\r\nCMake.prototype._run = function (command) {\r\n    this.log.info(\"RUN\", command);\r\n    return processHelpers.run(command, {silent: this.silent});\r\n};\r\n\r\nmodule.exports = CMake;\r\n"],"file":"cMake.js"}