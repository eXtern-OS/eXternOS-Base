<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Cally" version="2"/>
  <include name="Clutter" version="2"/>
  <include name="Gtk" version="3.0"/>
  <namespace name="St"
             version="1.0"
             shared-library="libst-1.0.so"
             c:identifier-prefixes="St"
             c:symbol-prefixes="st">
    <class name="Adjustment"
           c:symbol-prefix="adjustment"
           c:type="StAdjustment"
           parent="GObject.Object"
           glib:type-name="StAdjustment"
           glib:get-type="st_adjustment_get_type"
           glib:type-struct="AdjustmentClass">
      <constructor name="new" c:identifier="st_adjustment_new">
        <return-value transfer-ownership="full">
          <type name="Adjustment" c:type="StAdjustment*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="lower" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="upper" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="step_increment" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="page_increment" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="page_size" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="adjust_for_scroll_event"
              c:identifier="st_adjustment_adjust_for_scroll_event">
        <doc xml:space="preserve">Adjusts the adjustment using delta values from a scroll event.
You should use this instead of using st_adjustment_set_value()
as this method will tweak the values directly using the same
math as GTK+, to ensure that scrolling is consistent across
the environment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adjustment" transfer-ownership="none">
            <doc xml:space="preserve">An #StAdjustment</doc>
            <type name="Adjustment" c:type="StAdjustment*"/>
          </instance-parameter>
          <parameter name="delta" transfer-ownership="none">
            <doc xml:space="preserve">A delta, retrieved directly from clutter_event_get_scroll_delta()
  or similar.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="clamp_page" c:identifier="st_adjustment_clamp_page">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </instance-parameter>
          <parameter name="lower" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="upper" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="st_adjustment_get_value">
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="adjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_values" c:identifier="st_adjustment_get_values">
        <doc xml:space="preserve">Gets all of @adjustment's values at once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adjustment" transfer-ownership="none">
            <doc xml:space="preserve">an #StAdjustment</doc>
            <type name="Adjustment" c:type="StAdjustment*"/>
          </instance-parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the current value</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="lower"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the lower bound</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="upper"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the upper bound</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="step_increment"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the step increment</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="page_increment"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the page increment</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="page_size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the page size</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="st_adjustment_set_value">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_values" c:identifier="st_adjustment_set_values">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="lower" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="upper" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="step_increment" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="page_increment" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="page_size" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="lower"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="page-increment"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="page-size"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="step-increment"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="upper"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="value"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="last">
        <doc xml:space="preserve">Emitted when any of the adjustment values have changed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="AdjustmentClass"
            c:type="StAdjustmentClass"
            glib:is-gtype-struct-for="Adjustment">
      <doc xml:space="preserve">Base class for #StAdjustment.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="adjustment" transfer-ownership="none">
              <type name="Adjustment" c:type="StAdjustment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="Align"
                 glib:type-name="StAlign"
                 glib:get-type="st_align_get_type"
                 c:type="StAlign">
      <member name="start"
              value="0"
              c:identifier="ST_ALIGN_START"
              glib:nick="start">
      </member>
      <member name="middle"
              value="1"
              c:identifier="ST_ALIGN_MIDDLE"
              glib:nick="middle">
      </member>
      <member name="end" value="2" c:identifier="ST_ALIGN_END" glib:nick="end">
      </member>
    </enumeration>
    <enumeration name="BackgroundSize"
                 glib:type-name="StBackgroundSize"
                 glib:get-type="st_background_size_get_type"
                 c:type="StBackgroundSize">
      <member name="auto"
              value="0"
              c:identifier="ST_BACKGROUND_SIZE_AUTO"
              glib:nick="auto">
      </member>
      <member name="contain"
              value="1"
              c:identifier="ST_BACKGROUND_SIZE_CONTAIN"
              glib:nick="contain">
      </member>
      <member name="cover"
              value="2"
              c:identifier="ST_BACKGROUND_SIZE_COVER"
              glib:nick="cover">
      </member>
      <member name="fixed"
              value="3"
              c:identifier="ST_BACKGROUND_SIZE_FIXED"
              glib:nick="fixed">
      </member>
    </enumeration>
    <class name="Bin"
           c:symbol-prefix="bin"
           c:type="StBin"
           parent="Widget"
           glib:type-name="StBin"
           glib:get-type="st_bin_get_type"
           glib:type-struct="BinClass">
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <constructor name="new" c:identifier="st_bin_new">
        <doc xml:space="preserve">Creates a new #StBin, a simple container for one child.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created #StBin actor</doc>
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
      </constructor>
      <method name="get_alignment" c:identifier="st_bin_get_alignment">
        <doc xml:space="preserve">Retrieves the horizontal and vertical alignment of the child
inside a #StBin, as set by st_bin_set_alignment().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">a #StBin</doc>
            <type name="Bin" c:type="StBin*"/>
          </instance-parameter>
          <parameter name="x_align" transfer-ownership="none">
            <doc xml:space="preserve">return location for the horizontal alignment, or %NULL</doc>
            <type name="Align" c:type="StAlign*"/>
          </parameter>
          <parameter name="y_align" transfer-ownership="none">
            <doc xml:space="preserve">return location for the vertical alignment, or %NULL</doc>
            <type name="Align" c:type="StAlign*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="st_bin_get_child">
        <doc xml:space="preserve">Retrieves a pointer to the child of @bin.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #ClutterActor, or %NULL</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">a #StBin</doc>
            <type name="Bin" c:type="StBin*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fill" c:identifier="st_bin_get_fill">
        <doc xml:space="preserve">Retrieves the horizontal and vertical fill settings</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">a #StBin</doc>
            <type name="Bin" c:type="StBin*"/>
          </instance-parameter>
          <parameter name="x_fill"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the horizontal fill, or %NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="y_fill"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the vertical fill, or %NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alignment" c:identifier="st_bin_set_alignment">
        <doc xml:space="preserve">Sets the horizontal and vertical alignment of the child
inside a #StBin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">a #StBin</doc>
            <type name="Bin" c:type="StBin*"/>
          </instance-parameter>
          <parameter name="x_align" transfer-ownership="none">
            <doc xml:space="preserve">horizontal alignment</doc>
            <type name="Align" c:type="StAlign"/>
          </parameter>
          <parameter name="y_align" transfer-ownership="none">
            <doc xml:space="preserve">vertical alignment</doc>
            <type name="Align" c:type="StAlign"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_child" c:identifier="st_bin_set_child">
        <doc xml:space="preserve">Sets @child as the child of @bin.

If @bin already has a child, the previous child is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">a #StBin</doc>
            <type name="Bin" c:type="StBin*"/>
          </instance-parameter>
          <parameter name="child"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #ClutterActor, or %NULL</doc>
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_fill" c:identifier="st_bin_set_fill">
        <doc xml:space="preserve">Sets whether the child of @bin should fill out the horizontal
and/or vertical allocation of the parent</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">a #StBin</doc>
            <type name="Bin" c:type="StBin*"/>
          </instance-parameter>
          <parameter name="x_fill" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the child should fill horizontally the @bin</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="y_fill" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the child should fill vertically the @bin</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="child" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The child #ClutterActor of the #StBin container.</doc>
        <type name="Clutter.Actor"/>
      </property>
      <property name="x-align" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The horizontal alignment of the #StBin child.</doc>
        <type name="Align"/>
      </property>
      <property name="x-fill" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the child should fill the horizontal allocation</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="y-align" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The vertical alignment of the #StBin child.</doc>
        <type name="Align"/>
      </property>
      <property name="y-fill" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the child should fill the vertical allocation</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="Widget" c:type="StWidget"/>
      </field>
    </class>
    <record name="BinClass" c:type="StBinClass" glib:is-gtype-struct-for="Bin">
      <doc xml:space="preserve">The #StBinClass struct contains only private data</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="WidgetClass" c:type="StWidgetClass"/>
      </field>
    </record>
    <class name="BorderImage"
           c:symbol-prefix="border_image"
           c:type="StBorderImage"
           parent="GObject.Object"
           glib:type-name="StBorderImage"
           glib:get-type="st_border_image_get_type"
           glib:type-struct="BorderImageClass">
      <constructor name="new" c:identifier="st_border_image_new">
        <return-value transfer-ownership="full">
          <type name="BorderImage" c:type="StBorderImage*"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="border_top" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="border_right" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="border_bottom" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="border_left" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="scale_factor" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="equal" c:identifier="st_border_image_equal">
        <doc xml:space="preserve">Check if two border_image objects are identical.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the two border image objects are identical</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">a #StBorder_Image</doc>
            <type name="BorderImage" c:type="StBorderImage*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">a different #StBorder_Image</doc>
            <type name="BorderImage" c:type="StBorderImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_borders" c:identifier="st_border_image_get_borders">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="BorderImage" c:type="StBorderImage*"/>
          </instance-parameter>
          <parameter name="border_top" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="border_right" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="border_bottom" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="border_left" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_file" c:identifier="st_border_image_get_file">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GFile for the #StBorder_Image</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve">a #StBorder_Image</doc>
            <type name="BorderImage" c:type="StBorderImage*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="BorderImageClass"
            c:type="StBorderImageClass"
            glib:is-gtype-struct-for="BorderImage">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="BoxLayout"
           c:symbol-prefix="box_layout"
           c:type="StBoxLayout"
           parent="Widget"
           glib:type-name="StBoxLayout"
           glib:get-type="st_box_layout_get_type"
           glib:type-struct="BoxLayoutClass">
      <doc xml:space="preserve">The contents of this structure are private and should only be accessed
through the public API.</doc>
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <implements name="Scrollable"/>
      <constructor name="new" c:identifier="st_box_layout_new">
        <doc xml:space="preserve">Create a new #StBoxLayout.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a newly allocated #StBoxLayout</doc>
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
      </constructor>
      <method name="get_pack_start"
              c:identifier="st_box_layout_get_pack_start">
        <doc xml:space="preserve">Get the value of the #StBoxLayout::pack-start property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if pack-start is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">A #StBoxLayout</doc>
            <type name="BoxLayout" c:type="StBoxLayout*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vertical" c:identifier="st_box_layout_get_vertical">
        <doc xml:space="preserve">Get the value of the #StBoxLayout::vertical property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the layout is vertical</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">A #StBoxLayout</doc>
            <type name="BoxLayout" c:type="StBoxLayout*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_pack_start"
              c:identifier="st_box_layout_set_pack_start">
        <doc xml:space="preserve">Set the value of the #StBoxLayout::pack-start property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">A #StBoxLayout</doc>
            <type name="BoxLayout" c:type="StBoxLayout*"/>
          </instance-parameter>
          <parameter name="pack_start" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the layout should use pack-start</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vertical" c:identifier="st_box_layout_set_vertical">
        <doc xml:space="preserve">Set the value of the #StBoxLayout::vertical property</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">A #StBoxLayout</doc>
            <type name="BoxLayout" c:type="StBoxLayout*"/>
          </instance-parameter>
          <parameter name="vertical" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the layout should be vertical</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="pack-start" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="vertical" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Widget" c:type="StWidget"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BoxLayoutPrivate" c:type="StBoxLayoutPrivate*"/>
      </field>
    </class>
    <class name="BoxLayoutChild"
           c:symbol-prefix="box_layout_child"
           c:type="StBoxLayoutChild"
           parent="Clutter.ChildMeta"
           glib:type-name="StBoxLayoutChild"
           glib:get-type="st_box_layout_child_get_type"
           glib:type-struct="BoxLayoutChildClass">
      <doc xml:space="preserve">The contents of this structure are private and should only be accessed
through the public API.</doc>
      <property name="expand" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="x-align" writable="1" transfer-ownership="none">
        <type name="Align"/>
      </property>
      <property name="x-fill" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="y-align" writable="1" transfer-ownership="none">
        <type name="Align"/>
      </property>
      <property name="y-fill" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Clutter.ChildMeta" c:type="ClutterChildMeta"/>
      </field>
      <field name="x_fill_set" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="y_fill_set" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <record name="BoxLayoutChildClass"
            c:type="StBoxLayoutChildClass"
            glib:is-gtype-struct-for="BoxLayoutChild">
      <field name="parent_class">
        <type name="Clutter.ChildMetaClass" c:type="ClutterChildMetaClass"/>
      </field>
    </record>
    <record name="BoxLayoutChildPrivate"
            c:type="StBoxLayoutChildPrivate"
            disguised="1">
    </record>
    <record name="BoxLayoutClass"
            c:type="StBoxLayoutClass"
            glib:is-gtype-struct-for="BoxLayout">
      <field name="parent_class">
        <type name="WidgetClass" c:type="StWidgetClass"/>
      </field>
    </record>
    <record name="BoxLayoutPrivate" c:type="StBoxLayoutPrivate" disguised="1">
    </record>
    <class name="Button"
           c:symbol-prefix="button"
           c:type="StButton"
           parent="Bin"
           glib:type-name="StButton"
           glib:get-type="st_button_get_type"
           glib:type-struct="ButtonClass">
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <constructor name="new" c:identifier="st_button_new">
        <doc xml:space="preserve">Create a new button</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #StButton</doc>
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_label"
                   c:identifier="st_button_new_with_label">
        <doc xml:space="preserve">Create a new #StButton with the specified label</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #StButton</doc>
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
        <parameters>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">text to set the label to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="clicked">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transition">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="fake_release" c:identifier="st_button_fake_release">
        <doc xml:space="preserve">If this widget is holding a pointer grab, this function will
will ungrab it, and reset the pressed state.  The effect is
similar to if the user had released the mouse button, but without
emitting the clicked signal.

This function is useful if for example you want to do something
after the user is holding the mouse button for a given period of
time, breaking the grab.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">an #StButton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_button_mask" c:identifier="st_button_get_button_mask">
        <doc xml:space="preserve">Gets the mask of mouse buttons that @button emits the
#StButton::clicked signal for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mask of mouse buttons that @button emits the
#StButton::clicked signal for.</doc>
          <type name="ButtonMask" c:type="StButtonMask"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #StButton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_checked" c:identifier="st_button_get_checked">
        <doc xml:space="preserve">Get the state of the button that is in toggle mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the button is checked, or %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #StButton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_label" c:identifier="st_button_get_label">
        <doc xml:space="preserve">Get the text displayed on the button</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the text for the button. This must not be freed by the application</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #StButton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_toggle_mode" c:identifier="st_button_get_toggle_mode">
        <doc xml:space="preserve">Get the toggle mode status of the button.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if toggle mode is set, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #StButton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_button_mask" c:identifier="st_button_set_button_mask">
        <doc xml:space="preserve">Sets which mouse buttons @button emits #StButton::clicked for.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #Stbutton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">the mask of mouse buttons that @button responds to</doc>
            <type name="ButtonMask" c:type="StButtonMask"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_checked" c:identifier="st_button_set_checked">
        <doc xml:space="preserve">Sets the pressed state of the button. This is only really useful if the
button has #toggle-mode mode set to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #Stbutton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
          <parameter name="checked" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE or %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label" c:identifier="st_button_set_label">
        <doc xml:space="preserve">Sets the text displayed on the button</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #Stbutton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">text to set the label to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_toggle_mode" c:identifier="st_button_set_toggle_mode">
        <doc xml:space="preserve">Enables or disables toggle mode for the button. In toggle mode, the active
state will be "toggled" when the user clicks the button.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">a #Stbutton</doc>
            <type name="Button" c:type="StButton*"/>
          </instance-parameter>
          <parameter name="toggle" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE or %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="button-mask" writable="1" transfer-ownership="none">
        <type name="ButtonMask"/>
      </property>
      <property name="checked" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="label" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pressed" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="toggle-mode" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="Bin" c:type="StBin"/>
      </field>
      <glib:signal name="clicked" when="last">
        <doc xml:space="preserve">Emitted when the user activates the button, either with a mouse press and
release or with the keyboard.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clicked_button" transfer-ownership="none">
            <doc xml:space="preserve">the mouse button that was used</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ButtonClass"
            c:type="StButtonClass"
            glib:is-gtype-struct-for="Button">
      <field name="parent_class">
        <type name="BinClass" c:type="StBinClass"/>
      </field>
      <field name="transition">
        <callback name="transition">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="button" transfer-ownership="none">
              <type name="Button" c:type="StButton*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clicked">
        <callback name="clicked">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="button" transfer-ownership="none">
              <type name="Button" c:type="StButton*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="ButtonMask"
              glib:type-name="StButtonMask"
              glib:get-type="st_button_mask_get_type"
              c:type="StButtonMask">
      <doc xml:space="preserve">A mask representing which mouse buttons an StButton responds to.</doc>
      <member name="one"
              value="1"
              c:identifier="ST_BUTTON_ONE"
              glib:nick="one">
        <doc xml:space="preserve">button 1 (left)</doc>
      </member>
      <member name="two"
              value="2"
              c:identifier="ST_BUTTON_TWO"
              glib:nick="two">
        <doc xml:space="preserve">button 2 (middle)</doc>
      </member>
      <member name="three"
              value="4"
              c:identifier="ST_BUTTON_THREE"
              glib:nick="three">
        <doc xml:space="preserve">button 3 (right)</doc>
      </member>
    </bitfield>
    <class name="Clipboard"
           c:symbol-prefix="clipboard"
           c:type="StClipboard"
           parent="GObject.Object"
           glib:type-name="StClipboard"
           glib:get-type="st_clipboard_get_type"
           glib:type-struct="ClipboardClass">
      <doc xml:space="preserve">The contents of this structure is private and should only be accessed using
the provided API.</doc>
      <function name="get_default" c:identifier="st_clipboard_get_default">
        <doc xml:space="preserve">Get the global #StClipboard object that represents the clipboard.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #StClipboard owned by St and must not be
unrefferenced or freed.</doc>
          <type name="Clipboard" c:type="StClipboard*"/>
        </return-value>
      </function>
      <method name="get_text" c:identifier="st_clipboard_get_text">
        <doc xml:space="preserve">Request the data from the clipboard in text form. @callback is executed
when the data is retreived.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="clipboard" transfer-ownership="none">
            <doc xml:space="preserve">A #StCliboard</doc>
            <type name="Clipboard" c:type="StClipboard*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of clipboard data you want</doc>
            <type name="ClipboardType" c:type="StClipboardType"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">function to be called when the text is retreived</doc>
            <type name="ClipboardCallbackFunc"
                  c:type="StClipboardCallbackFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_text" c:identifier="st_clipboard_set_text">
        <doc xml:space="preserve">Sets text as the current contents of the clipboard.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="clipboard" transfer-ownership="none">
            <doc xml:space="preserve">A #StClipboard</doc>
            <type name="Clipboard" c:type="StClipboard*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of clipboard that you want to set</doc>
            <type name="ClipboardType" c:type="StClipboardType"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">text to copy to the clipboard</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ClipboardPrivate" c:type="StClipboardPrivate*"/>
      </field>
    </class>
    <callback name="ClipboardCallbackFunc" c:type="StClipboardCallbackFunc">
      <doc xml:space="preserve">Callback function called when text is retrieved from the clipboard.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="clipboard" transfer-ownership="none">
          <doc xml:space="preserve">A #StClipboard</doc>
          <type name="Clipboard" c:type="StClipboard*"/>
        </parameter>
        <parameter name="text" transfer-ownership="none">
          <doc xml:space="preserve">text from the clipboard</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClipboardClass"
            c:type="StClipboardClass"
            glib:is-gtype-struct-for="Clipboard">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ClipboardPrivate" c:type="StClipboardPrivate" disguised="1">
    </record>
    <enumeration name="ClipboardType"
                 glib:type-name="StClipboardType"
                 glib:get-type="st_clipboard_type_get_type"
                 c:type="StClipboardType">
      <member name="primary"
              value="0"
              c:identifier="ST_CLIPBOARD_TYPE_PRIMARY"
              glib:nick="primary">
      </member>
      <member name="clipboard"
              value="1"
              c:identifier="ST_CLIPBOARD_TYPE_CLIPBOARD"
              glib:nick="clipboard">
      </member>
    </enumeration>
    <enumeration name="Corner"
                 glib:type-name="StCorner"
                 glib:get-type="st_corner_get_type"
                 c:type="StCorner">
      <member name="topleft"
              value="0"
              c:identifier="ST_CORNER_TOPLEFT"
              glib:nick="topleft">
      </member>
      <member name="topright"
              value="1"
              c:identifier="ST_CORNER_TOPRIGHT"
              glib:nick="topright">
      </member>
      <member name="bottomright"
              value="2"
              c:identifier="ST_CORNER_BOTTOMRIGHT"
              glib:nick="bottomright">
      </member>
      <member name="bottomleft"
              value="3"
              c:identifier="ST_CORNER_BOTTOMLEFT"
              glib:nick="bottomleft">
      </member>
    </enumeration>
    <class name="DrawingArea"
           c:symbol-prefix="drawing_area"
           c:type="StDrawingArea"
           parent="Widget"
           glib:type-name="StDrawingArea"
           glib:get-type="st_drawing_area_get_type"
           glib:type-struct="DrawingAreaClass">
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <virtual-method name="repaint">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <type name="DrawingArea" c:type="StDrawingArea*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_context" c:identifier="st_drawing_area_get_context">
        <doc xml:space="preserve">Gets the Cairo context to paint to. This function must only be called
from a signal hander for the ::repaint signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Cairo context for the paint operation</doc>
          <type name="cairo.Context" c:type="cairo_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">the #StDrawingArea</doc>
            <type name="DrawingArea" c:type="StDrawingArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_surface_size"
              c:identifier="st_drawing_area_get_surface_size">
        <doc xml:space="preserve">Gets the size of the cairo surface being painted to, which is equal
to the size of the content area of the widget. This function must
only be called from a signal hander for the ::repaint signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">the #StDrawingArea</doc>
            <type name="DrawingArea" c:type="StDrawingArea*"/>
          </instance-parameter>
          <parameter name="width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store the width of the painted area</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store the height of the painted area</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="queue_repaint"
              c:identifier="st_drawing_area_queue_repaint">
        <doc xml:space="preserve">Will cause the actor to emit a ::repaint signal before it is next
drawn to the scene. Useful if some parameters for the area being
drawn other than the size or style have changed. Note that
clutter_actor_queue_redraw() will simply result in the same
contents being drawn to the scene again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">the #StDrawingArea</doc>
            <type name="DrawingArea" c:type="StDrawingArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Widget" c:type="StWidget"/>
      </field>
      <glib:signal name="repaint" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="DrawingAreaClass"
            c:type="StDrawingAreaClass"
            glib:is-gtype-struct-for="DrawingArea">
      <field name="parent_class">
        <type name="WidgetClass" c:type="StWidgetClass"/>
      </field>
      <field name="repaint">
        <callback name="repaint">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="area" transfer-ownership="none">
              <type name="DrawingArea" c:type="StDrawingArea*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="Entry"
           c:symbol-prefix="entry"
           c:type="StEntry"
           parent="Widget"
           glib:type-name="StEntry"
           glib:get-type="st_entry_get_type"
           glib:type-struct="EntryClass">
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <constructor name="new" c:identifier="st_entry_new">
        <doc xml:space="preserve">Create a new #StEntry with the specified entry</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #StEntry</doc>
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
        <parameters>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">text to set the entry to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="set_cursor_func"
                c:identifier="st_entry_set_cursor_func"
                introspectable="0">
        <doc xml:space="preserve">This function is for private use by libgnome-shell.
Do not ever use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <type name="EntryCursorFunc" c:type="StEntryCursorFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="primary_icon_clicked">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="secondary_icon_clicked">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_clutter_text" c:identifier="st_entry_get_clutter_text">
        <doc xml:space="preserve">Retrieve the internal #ClutterText so that extra parameters can be set</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #ClutterText used by #StEntry. The entry is
owned by the #StEntry and should not be unref'ed by the application.</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hint_actor" c:identifier="st_entry_get_hint_actor">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #ClutterActor</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hint_text" c:identifier="st_entry_get_hint_text">
        <doc xml:space="preserve">Gets the text that is displayed when the entry is empty and unfocused</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current value of the hint property. This string is owned by the
#StEntry and should not be freed or modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_input_hints" c:identifier="st_entry_get_input_hints">
        <doc xml:space="preserve">Gets the value of the #StEntry:input-hints property.</doc>
        <return-value transfer-ownership="none">
          <type name="Clutter.InputContentHintFlags"
                c:type="ClutterInputContentHintFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_input_purpose"
              c:identifier="st_entry_get_input_purpose">
        <doc xml:space="preserve">Gets the value of the #StEntry:input-purpose property.</doc>
        <return-value transfer-ownership="none">
          <type name="Clutter.InputContentPurpose"
                c:type="ClutterInputContentPurpose"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_primary_icon" c:identifier="st_entry_get_primary_icon">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #ClutterActor</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secondary_icon"
              c:identifier="st_entry_get_secondary_icon">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #ClutterActor</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_text" c:identifier="st_entry_get_text">
        <doc xml:space="preserve">Get the text displayed on the entry</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the text for the entry. This must not be freed by the application</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_hint_actor" c:identifier="st_entry_set_hint_actor">
        <doc xml:space="preserve">Set the hint actor of the entry to @hint_actor</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
          <parameter name="hint_actor"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #ClutterActor</doc>
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hint_text" c:identifier="st_entry_set_hint_text">
        <doc xml:space="preserve">Sets the text to display when the entry is empty and unfocused. When the
entry is displaying the hint, it has a pseudo class of "indeterminate".
A value of NULL unsets the hint.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
          <parameter name="text"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">text to set as the entry hint</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_input_hints" c:identifier="st_entry_set_input_hints">
        <doc xml:space="preserve">Sets the #StEntry:input-hints property, which
allows input methods to fine-tune their behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">the hints</doc>
            <type name="Clutter.InputContentHintFlags"
                  c:type="ClutterInputContentHintFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_input_purpose"
              c:identifier="st_entry_set_input_purpose">
        <doc xml:space="preserve">Sets the #StEntry:input-purpose property which
can be used by on-screen keyboards and other input
methods to adjust their behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
          <parameter name="purpose" transfer-ownership="none">
            <doc xml:space="preserve">the purpose</doc>
            <type name="Clutter.InputContentPurpose"
                  c:type="ClutterInputContentPurpose"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_primary_icon" c:identifier="st_entry_set_primary_icon">
        <doc xml:space="preserve">Set the primary icon of the entry to @icon</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
          <parameter name="icon"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #ClutterActor</doc>
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_secondary_icon"
              c:identifier="st_entry_set_secondary_icon">
        <doc xml:space="preserve">Set the secondary icon of the entry to @icon</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
          <parameter name="icon"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an #ClutterActor</doc>
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_text" c:identifier="st_entry_set_text">
        <doc xml:space="preserve">Sets the text displayed on the entry</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve">a #StEntry</doc>
            <type name="Entry" c:type="StEntry*"/>
          </instance-parameter>
          <parameter name="text"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">text to set the entry to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="clutter-text" transfer-ownership="none">
        <type name="Clutter.Text"/>
      </property>
      <property name="hint-actor" writable="1" transfer-ownership="none">
        <type name="Clutter.Actor"/>
      </property>
      <property name="hint-text" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="input-hints" writable="1" transfer-ownership="none">
        <type name="Clutter.InputContentHintFlags"/>
      </property>
      <property name="input-purpose" writable="1" transfer-ownership="none">
        <type name="Clutter.InputContentPurpose"/>
      </property>
      <property name="primary-icon" writable="1" transfer-ownership="none">
        <type name="Clutter.Actor"/>
      </property>
      <property name="secondary-icon" writable="1" transfer-ownership="none">
        <type name="Clutter.Actor"/>
      </property>
      <property name="text" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="Widget" c:type="StWidget"/>
      </field>
      <glib:signal name="primary-icon-clicked" when="last">
        <doc xml:space="preserve">Emitted when the primary icon is clicked</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secondary-icon-clicked" when="last">
        <doc xml:space="preserve">Emitted when the secondary icon is clicked</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="EntryClass"
            c:type="StEntryClass"
            glib:is-gtype-struct-for="Entry">
      <field name="parent_class">
        <type name="WidgetClass" c:type="StWidgetClass"/>
      </field>
      <field name="primary_icon_clicked">
        <callback name="primary_icon_clicked">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entry" transfer-ownership="none">
              <type name="Entry" c:type="StEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="secondary_icon_clicked">
        <callback name="secondary_icon_clicked">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entry" transfer-ownership="none">
              <type name="Entry" c:type="StEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="EntryCursorFunc" c:type="StEntryCursorFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="entry" transfer-ownership="none">
          <type name="Entry" c:type="StEntry*"/>
        </parameter>
        <parameter name="use_ibeam" transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="FocusManager"
           c:symbol-prefix="focus_manager"
           c:type="StFocusManager"
           parent="GObject.Object"
           glib:type-name="StFocusManager"
           glib:get-type="st_focus_manager_get_type"
           glib:type-struct="FocusManagerClass">
      <doc xml:space="preserve">The #StFocusManager struct contains only private data</doc>
      <function name="get_for_stage"
                c:identifier="st_focus_manager_get_for_stage">
        <doc xml:space="preserve">Gets the #StFocusManager for @stage, creating it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the focus manager for @stage</doc>
          <type name="FocusManager" c:type="StFocusManager*"/>
        </return-value>
        <parameters>
          <parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #ClutterStage</doc>
            <type name="Clutter.Stage" c:type="ClutterStage*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_group" c:identifier="st_focus_manager_add_group">
        <doc xml:space="preserve">Adds a new focus group to @manager. When the focus is in an actor
that is a descendant of @root, @manager will handle moving focus
from one actor to another within @root based on keyboard events.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">the #StFocusManager</doc>
            <type name="FocusManager" c:type="StFocusManager*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root container of the group</doc>
            <type name="Widget" c:type="StWidget*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_group" c:identifier="st_focus_manager_get_group">
        <doc xml:space="preserve">Checks if @widget is inside a focus group, and if so, returns
the root of that group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the focus group root, or %NULL if
@widget is not in a focus group</doc>
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">the #StFocusManager</doc>
            <type name="FocusManager" c:type="StFocusManager*"/>
          </instance-parameter>
          <parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">an #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </parameter>
        </parameters>
      </method>
      <method name="navigate_from_event"
              c:identifier="st_focus_manager_navigate_from_event">
        <doc xml:space="preserve">Try to navigate from @event as if it bubbled all the way up to
the stage. This is useful in complex event handling situations
where you want key navigation, but a parent might be stopping
the key navigation event from bubbling all the way up to the stage.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether a new actor was navigated to</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">the #StFocusManager</doc>
            <type name="FocusManager" c:type="StFocusManager*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">a #ClutterEvent</doc>
            <type name="Clutter.Event" c:type="ClutterEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group" c:identifier="st_focus_manager_remove_group">
        <doc xml:space="preserve">Removes the group rooted at @root from @manager</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">the #StFocusManager</doc>
            <type name="FocusManager" c:type="StFocusManager*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root container of the group</doc>
            <type name="Widget" c:type="StWidget*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FocusManagerPrivate" c:type="StFocusManagerPrivate*"/>
      </field>
    </class>
    <record name="FocusManagerClass"
            c:type="StFocusManagerClass"
            glib:is-gtype-struct-for="FocusManager">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="FocusManagerPrivate"
            c:type="StFocusManagerPrivate"
            disguised="1">
    </record>
    <class name="GenericAccessible"
           c:symbol-prefix="generic_accessible"
           c:type="StGenericAccessible"
           parent="WidgetAccessible"
           glib:type-name="StGenericAccessible"
           glib:get-type="st_generic_accessible_get_type"
           glib:type-struct="GenericAccessibleClass">
      <implements name="Atk.Action"/>
      <implements name="Atk.Component"/>
      <implements name="Atk.Value"/>
      <constructor name="new_for_actor"
                   c:identifier="st_generic_accessible_new_for_actor">
        <return-value transfer-ownership="full">
          <type name="Atk.Object" c:type="AtkObject*"/>
        </return-value>
        <parameters>
          <parameter name="actor" transfer-ownership="none">
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="WidgetAccessible" c:type="StWidgetAccessible"/>
      </field>
      <field name="priv">
        <type name="GenericAccessiblePrivate"
              c:type="StGenericAccessiblePrivate*"/>
      </field>
      <glib:signal name="get-current-value" when="last">
        <doc xml:space="preserve">Emitted when atk_value_get_current_value() is called on
@self. Right now we only care about doubles, so the value is
directly returned by the signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">value of the current element.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
      </glib:signal>
      <glib:signal name="get-maximum-value" when="last">
        <doc xml:space="preserve">Emitted when atk_value_get_maximum_value() is called on
@self. Right now we only care about doubles, so the value is
directly returned by the signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">maximum value of the accessible.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
      </glib:signal>
      <glib:signal name="get-minimum-increment" when="last">
        <doc xml:space="preserve">Emitted when atk_value_get_minimum_increment() is called on
@self. Right now we only care about doubles, so the value is
directly returned by the signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">value of the current element.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
      </glib:signal>
      <glib:signal name="get-minimum-value" when="last">
        <doc xml:space="preserve">Emitted when atk_value_get_current_value() is called on
@self. Right now we only care about doubles, so the value is
directly returned by the signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">minimum value of the accessible.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
      </glib:signal>
      <glib:signal name="set-current-value" when="last">
        <doc xml:space="preserve">Emitted when atk_value_set_current_value() is called on
@self. Right now we only care about doubles, so the value is
directly returned by the signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="new_value" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the accessible</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="GenericAccessibleClass"
            c:type="StGenericAccessibleClass"
            glib:is-gtype-struct-for="GenericAccessible">
      <field name="parent_class">
        <type name="WidgetAccessibleClass" c:type="StWidgetAccessibleClass"/>
      </field>
    </record>
    <record name="GenericAccessiblePrivate"
            c:type="StGenericAccessiblePrivate"
            disguised="1">
    </record>
    <enumeration name="GradientType"
                 glib:type-name="StGradientType"
                 glib:get-type="st_gradient_type_get_type"
                 c:type="StGradientType">
      <member name="none"
              value="0"
              c:identifier="ST_GRADIENT_NONE"
              glib:nick="none">
      </member>
      <member name="vertical"
              value="1"
              c:identifier="ST_GRADIENT_VERTICAL"
              glib:nick="vertical">
      </member>
      <member name="horizontal"
              value="2"
              c:identifier="ST_GRADIENT_HORIZONTAL"
              glib:nick="horizontal">
      </member>
      <member name="radial"
              value="3"
              c:identifier="ST_GRADIENT_RADIAL"
              glib:nick="radial">
      </member>
    </enumeration>
    <class name="Icon"
           c:symbol-prefix="icon"
           c:type="StIcon"
           parent="Widget"
           glib:type-name="StIcon"
           glib:get-type="st_icon_get_type"
           glib:type-struct="IconClass">
      <doc xml:space="preserve">The contents of this structure are private and should only be accessed
through the public API.</doc>
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <constructor name="new" c:identifier="st_icon_new">
        <doc xml:space="preserve">Create a newly allocated #StIcon</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A newly allocated #StIcon</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
      </constructor>
      <method name="get_fallback_icon_name"
              c:identifier="st_icon_get_fallback_icon_name">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gicon" c:identifier="st_icon_get_gicon">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the override GIcon, if set, or NULL</doc>
          <type name="Gio.Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">an icon</doc>
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon_name" c:identifier="st_icon_get_icon_name">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon_size" c:identifier="st_icon_get_icon_size">
        <doc xml:space="preserve">Gets the size explicit size on the icon. This is not necesariily
 the size that the icon will actually be displayed at.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size explicitly set, or -1 if no size has been set</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">an icon</doc>
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_fallback_icon_name"
              c:identifier="st_icon_set_fallback_icon_name">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
          <parameter name="icon_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gicon" c:identifier="st_icon_set_gicon">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">an icon</doc>
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
          <parameter name="gicon"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GIcon to override :icon-name</doc>
            <type name="Gio.Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name" c:identifier="st_icon_set_icon_name">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
          <parameter name="icon_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_size" c:identifier="st_icon_set_icon_size">
        <doc xml:space="preserve">Sets an explicit size for the icon.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">an icon</doc>
            <type name="Icon" c:type="StIcon*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">if positive, the new size, otherwise the size will be
  derived from the current style</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <property name="fallback-icon-name"
                writable="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="gicon" writable="1" transfer-ownership="none">
        <type name="Gio.Icon"/>
      </property>
      <property name="icon-name" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="icon-size" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Widget" c:type="StWidget"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="IconPrivate" c:type="StIconPrivate*"/>
      </field>
    </class>
    <record name="IconClass"
            c:type="StIconClass"
            glib:is-gtype-struct-for="Icon">
      <field name="parent_class">
        <type name="WidgetClass" c:type="StWidgetClass"/>
      </field>
    </record>
    <record name="IconColors"
            c:type="StIconColors"
            glib:type-name="StIconColors"
            glib:get-type="st_icon_colors_get_type"
            c:symbol-prefix="icon_colors">
      <doc xml:space="preserve">The #StIconColors structure encapsulates colors for colorizing a symbolic
icon.</doc>
      <field name="ref_count" writable="1">
        <type name="guint" c:type="volatile guint"/>
      </field>
      <field name="foreground" writable="1">
        <doc xml:space="preserve">foreground color</doc>
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="warning" writable="1">
        <doc xml:space="preserve">color indicating a warning state</doc>
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="error" writable="1">
        <doc xml:space="preserve">color indicating an error state</doc>
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="success" writable="1">
        <doc xml:space="preserve">color indicating a successful operation</doc>
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <constructor name="new" c:identifier="st_icon_colors_new">
        <doc xml:space="preserve">Creates a new #StIconColors. All colors are initialized to transparent black.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #StIconColors. Free with st_icon_colors_unref()</doc>
          <type name="IconColors" c:type="StIconColors*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="st_icon_colors_copy">
        <doc xml:space="preserve">Creates a new StIconColors structure that is a copy of the passed
in @colors. You would use this function instead of st_icon_colors_ref()
if you were planning to change colors in the result.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #StIconColors.</doc>
          <type name="IconColors" c:type="StIconColors*"/>
        </return-value>
        <parameters>
          <instance-parameter name="colors" transfer-ownership="none">
            <doc xml:space="preserve">a #StIconColors</doc>
            <type name="IconColors" c:type="StIconColors*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="st_icon_colors_ref">
        <doc xml:space="preserve">Atomically increments the reference count of @colors by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #StIconColors.</doc>
          <type name="IconColors" c:type="StIconColors*"/>
        </return-value>
        <parameters>
          <instance-parameter name="colors" transfer-ownership="none">
            <doc xml:space="preserve">a #StIconColors</doc>
            <type name="IconColors" c:type="StIconColors*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="st_icon_colors_unref">
        <doc xml:space="preserve">Atomically decrements the reference count of @colors by one.
If the reference count drops to 0, all memory allocated by the
#StIconColors is released.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="colors" transfer-ownership="none">
            <doc xml:space="preserve">a #StIconColors</doc>
            <type name="IconColors" c:type="StIconColors*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="IconPrivate" c:type="StIconPrivate" disguised="1">
    </record>
    <enumeration name="IconStyle"
                 glib:type-name="StIconStyle"
                 glib:get-type="st_icon_style_get_type"
                 c:type="StIconStyle">
      <member name="requested"
              value="0"
              c:identifier="ST_ICON_STYLE_REQUESTED"
              glib:nick="requested">
      </member>
      <member name="regular"
              value="1"
              c:identifier="ST_ICON_STYLE_REGULAR"
              glib:nick="regular">
      </member>
      <member name="symbolic"
              value="2"
              c:identifier="ST_ICON_STYLE_SYMBOLIC"
              glib:nick="symbolic">
      </member>
    </enumeration>
    <class name="Label"
           c:symbol-prefix="label"
           c:type="StLabel"
           parent="Widget"
           glib:type-name="StLabel"
           glib:get-type="st_label_get_type"
           glib:type-struct="LabelClass">
      <doc xml:space="preserve">The contents of this structure is private and should only be accessed using
the provided API.</doc>
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <constructor name="new" c:identifier="st_label_new">
        <doc xml:space="preserve">Create a new #StLabel with the specified label</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #StLabel</doc>
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
        <parameters>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">text to set the label to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_clutter_text" c:identifier="st_label_get_clutter_text">
        <doc xml:space="preserve">Retrieve the internal #ClutterText so that extra parameters can be set</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">ethe #ClutterText used by #StLabel. The label
is owned by the #StLabel and should not be unref'ed by the application.</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">a #StLabel</doc>
            <type name="Label" c:type="StLabel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_text" c:identifier="st_label_get_text">
        <doc xml:space="preserve">Get the text displayed on the label</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the text for the label. This must not be freed by the application</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">a #StLabel</doc>
            <type name="Label" c:type="StLabel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_text" c:identifier="st_label_set_text">
        <doc xml:space="preserve">Sets the text displayed on the label</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">a #StLabel</doc>
            <type name="Label" c:type="StLabel*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">text to set the label to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="clutter-text" transfer-ownership="none">
        <type name="Clutter.Text"/>
      </property>
      <property name="text" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="Widget" c:type="StWidget"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="LabelPrivate" c:type="StLabelPrivate*"/>
      </field>
    </class>
    <record name="LabelClass"
            c:type="StLabelClass"
            glib:is-gtype-struct-for="Label">
      <field name="parent_class">
        <type name="WidgetClass" c:type="StWidgetClass"/>
      </field>
    </record>
    <record name="LabelPrivate" c:type="StLabelPrivate" disguised="1">
    </record>
    <constant name="PARAM_READABLE" value="225" c:type="ST_PARAM_READABLE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_READWRITE" value="227" c:type="ST_PARAM_READWRITE">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="ScrollBar"
           c:symbol-prefix="scroll_bar"
           c:type="StScrollBar"
           parent="Widget"
           glib:type-name="StScrollBar"
           glib:get-type="st_scroll_bar_get_type"
           glib:type-struct="ScrollBarClass">
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <constructor name="new" c:identifier="st_scroll_bar_new">
        <return-value transfer-ownership="none">
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
        <parameters>
          <parameter name="adjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="scroll_start">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bar" transfer-ownership="none">
            <type name="ScrollBar" c:type="StScrollBar*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="scroll_stop">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bar" transfer-ownership="none">
            <type name="ScrollBar" c:type="StScrollBar*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_adjustment"
              c:identifier="st_scroll_bar_get_adjustment">
        <doc xml:space="preserve">Gets the adjustment object that stores the current position
of the scrollbar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the adjustment</doc>
          <type name="Adjustment" c:type="StAdjustment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bar" transfer-ownership="none">
            <doc xml:space="preserve">a #StScrollbar</doc>
            <type name="ScrollBar" c:type="StScrollBar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_adjustment"
              c:identifier="st_scroll_bar_set_adjustment">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bar" transfer-ownership="none">
            <type name="ScrollBar" c:type="StScrollBar*"/>
          </instance-parameter>
          <parameter name="adjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </parameter>
        </parameters>
      </method>
      <property name="adjustment" writable="1" transfer-ownership="none">
        <type name="Adjustment"/>
      </property>
      <property name="vertical" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="Widget" c:type="StWidget"/>
      </field>
      <glib:signal name="scroll-start" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="scroll-stop" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ScrollBarClass"
            c:type="StScrollBarClass"
            glib:is-gtype-struct-for="ScrollBar">
      <field name="parent_class">
        <type name="WidgetClass" c:type="StWidgetClass"/>
      </field>
      <field name="scroll_start">
        <callback name="scroll_start">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bar" transfer-ownership="none">
              <type name="ScrollBar" c:type="StScrollBar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="scroll_stop">
        <callback name="scroll_stop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bar" transfer-ownership="none">
              <type name="ScrollBar" c:type="StScrollBar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ScrollView"
           c:symbol-prefix="scroll_view"
           c:type="StScrollView"
           parent="Bin"
           glib:type-name="StScrollView"
           glib:get-type="st_scroll_view_get_type"
           glib:type-struct="ScrollViewClass">
      <doc xml:space="preserve">The contents of this structure are private and should only be accessed
through the public API.</doc>
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <constructor name="new" c:identifier="st_scroll_view_new">
        <return-value transfer-ownership="none">
          <type name="Widget" c:type="StWidget*"/>
        </return-value>
      </constructor>
      <method name="get_column_size"
              c:identifier="st_scroll_view_get_column_size">
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hscroll_bar"
              c:identifier="st_scroll_view_get_hscroll_bar">
        <doc xml:space="preserve">Gets the horizontal scrollbar of the scrollbiew</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the horizontal #StScrollBar</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <doc xml:space="preserve">a #StScrollView</doc>
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mouse_scrolling"
              c:identifier="st_scroll_view_get_mouse_scrolling">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_overlay_scrollbars"
              c:identifier="st_scroll_view_get_overlay_scrollbars">
        <doc xml:space="preserve">Gets the value set by st_scroll_view_set_overlay_scrollbars().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <doc xml:space="preserve">A #StScrollView</doc>
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_row_size" c:identifier="st_scroll_view_get_row_size">
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vscroll_bar"
              c:identifier="st_scroll_view_get_vscroll_bar">
        <doc xml:space="preserve">Gets the vertical scrollbar of the scrollbiew</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the vertical #StScrollBar</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <doc xml:space="preserve">a #StScrollView</doc>
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_column_size"
              c:identifier="st_scroll_view_set_column_size">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
          <parameter name="column_size" transfer-ownership="none">
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mouse_scrolling"
              c:identifier="st_scroll_view_set_mouse_scrolling">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_overlay_scrollbars"
              c:identifier="st_scroll_view_set_overlay_scrollbars">
        <doc xml:space="preserve">Sets whether scrollbars are painted on top of the content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <doc xml:space="preserve">A #StScrollView</doc>
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">Whether to enable overlay scrollbars</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_policy" c:identifier="st_scroll_view_set_policy">
        <doc xml:space="preserve">Set the scroll policy.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <doc xml:space="preserve">A #StScrollView</doc>
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
          <parameter name="hscroll" transfer-ownership="none">
            <doc xml:space="preserve">Whether to enable horizontal scrolling</doc>
            <type name="Gtk.PolicyType" c:type="GtkPolicyType"/>
          </parameter>
          <parameter name="vscroll" transfer-ownership="none">
            <doc xml:space="preserve">Whether to enable vertical scrolling</doc>
            <type name="Gtk.PolicyType" c:type="GtkPolicyType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_row_size" c:identifier="st_scroll_view_set_row_size">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
          <parameter name="row_size" transfer-ownership="none">
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_fade_effect"
              c:identifier="st_scroll_view_update_fade_effect">
        <doc xml:space="preserve">Sets the height of the fade area area in pixels. A value of 0
disables the effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scroll" transfer-ownership="none">
            <doc xml:space="preserve">a #StScrollView</doc>
            <type name="ScrollView" c:type="StScrollView*"/>
          </instance-parameter>
          <parameter name="vfade_offset" transfer-ownership="none">
            <doc xml:space="preserve">The length of the veritcal fade effect, in pixels.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="hfade_offset" transfer-ownership="none">
            <doc xml:space="preserve">The length of the horizontal fade effect, in pixels.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <property name="enable-mouse-scrolling"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hscroll" transfer-ownership="none">
        <type name="ScrollBar"/>
      </property>
      <property name="hscrollbar-policy"
                writable="1"
                transfer-ownership="none">
        <type name="Gtk.PolicyType"/>
      </property>
      <property name="hscrollbar-visible" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="overlay-scrollbars"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="vscroll" transfer-ownership="none">
        <type name="ScrollBar"/>
      </property>
      <property name="vscrollbar-policy"
                writable="1"
                transfer-ownership="none">
        <type name="Gtk.PolicyType"/>
      </property>
      <property name="vscrollbar-visible" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="Bin" c:type="StBin"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ScrollViewPrivate" c:type="StScrollViewPrivate*"/>
      </field>
    </class>
    <record name="ScrollViewClass"
            c:type="StScrollViewClass"
            glib:is-gtype-struct-for="ScrollView">
      <field name="parent_class">
        <type name="BinClass" c:type="StBinClass"/>
      </field>
    </record>
    <record name="ScrollViewPrivate"
            c:type="StScrollViewPrivate"
            disguised="1">
    </record>
    <interface name="Scrollable"
               c:symbol-prefix="scrollable"
               c:type="StScrollable"
               glib:type-name="StScrollable"
               glib:get-type="st_scrollable_get_type"
               glib:type-struct="ScrollableInterface">
      <virtual-method name="get_adjustments" invoker="get_adjustments">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scrollable" transfer-ownership="none">
            <type name="Scrollable" c:type="StScrollable*"/>
          </instance-parameter>
          <parameter name="hadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment**"/>
          </parameter>
          <parameter name="vadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_adjustments" invoker="set_adjustments">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scrollable" transfer-ownership="none">
            <type name="Scrollable" c:type="StScrollable*"/>
          </instance-parameter>
          <parameter name="hadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </parameter>
          <parameter name="vadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_adjustments"
              c:identifier="st_scrollable_get_adjustments">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scrollable" transfer-ownership="none">
            <type name="Scrollable" c:type="StScrollable*"/>
          </instance-parameter>
          <parameter name="hadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment**"/>
          </parameter>
          <parameter name="vadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_adjustments"
              c:identifier="st_scrollable_set_adjustments">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scrollable" transfer-ownership="none">
            <type name="Scrollable" c:type="StScrollable*"/>
          </instance-parameter>
          <parameter name="hadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </parameter>
          <parameter name="vadjustment" transfer-ownership="none">
            <type name="Adjustment" c:type="StAdjustment*"/>
          </parameter>
        </parameters>
      </method>
      <property name="hadjustment" writable="1" transfer-ownership="none">
        <type name="Adjustment"/>
      </property>
      <property name="vadjustment" writable="1" transfer-ownership="none">
        <type name="Adjustment"/>
      </property>
    </interface>
    <record name="ScrollableInterface"
            c:type="StScrollableInterface"
            glib:is-gtype-struct-for="Scrollable">
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="set_adjustments">
        <callback name="set_adjustments">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="scrollable" transfer-ownership="none">
              <type name="Scrollable" c:type="StScrollable*"/>
            </parameter>
            <parameter name="hadjustment" transfer-ownership="none">
              <type name="Adjustment" c:type="StAdjustment*"/>
            </parameter>
            <parameter name="vadjustment" transfer-ownership="none">
              <type name="Adjustment" c:type="StAdjustment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_adjustments">
        <callback name="get_adjustments">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="scrollable" transfer-ownership="none">
              <type name="Scrollable" c:type="StScrollable*"/>
            </parameter>
            <parameter name="hadjustment" transfer-ownership="none">
              <type name="Adjustment" c:type="StAdjustment**"/>
            </parameter>
            <parameter name="vadjustment" transfer-ownership="none">
              <type name="Adjustment" c:type="StAdjustment**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="Shadow"
            c:type="StShadow"
            glib:type-name="StShadow"
            glib:get-type="st_shadow_get_type"
            c:symbol-prefix="shadow">
      <doc xml:space="preserve">Attributes of the -st-shadow property.</doc>
      <field name="color" writable="1">
        <doc xml:space="preserve">shadow's color</doc>
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="xoffset" writable="1">
        <doc xml:space="preserve">horizontal offset - positive values mean placement to the right,
          negative values placement to the left of the element.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="yoffset" writable="1">
        <doc xml:space="preserve">vertical offset - positive values mean placement below, negative
          values placement above the element.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="blur" writable="1">
        <doc xml:space="preserve">shadow's blur radius - a value of 0.0 will result in a hard shadow.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="spread" writable="1">
        <doc xml:space="preserve">shadow's spread radius - grow the shadow without enlarging the
          blur.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="inset" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="volatile int"/>
      </field>
      <constructor name="new" c:identifier="st_shadow_new">
        <doc xml:space="preserve">Creates a new #StShadow</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated shadow. Use st_shadow_free() when done</doc>
          <type name="Shadow" c:type="StShadow*"/>
        </return-value>
        <parameters>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">shadow's color</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
          <parameter name="xoffset" transfer-ownership="none">
            <doc xml:space="preserve">horizontal offset</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="yoffset" transfer-ownership="none">
            <doc xml:space="preserve">vertical offset</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="blur" transfer-ownership="none">
            <doc xml:space="preserve">blur radius</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="spread" transfer-ownership="none">
            <doc xml:space="preserve">spread radius</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="inset" transfer-ownership="none">
            <doc xml:space="preserve">whether the shadow should be inset</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="equal" c:identifier="st_shadow_equal">
        <doc xml:space="preserve">Check if two shadow objects are identical. Note that two shadows may
compare non-identically if they differ only by floating point rounding
errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the two shadows are identical</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shadow" transfer-ownership="none">
            <doc xml:space="preserve">a #StShadow</doc>
            <type name="Shadow" c:type="StShadow*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">a different #StShadow</doc>
            <type name="Shadow" c:type="StShadow*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_box" c:identifier="st_shadow_get_box">
        <doc xml:space="preserve">Gets the box used to paint @shadow, which will be partly
outside of @actor_box</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shadow" transfer-ownership="none">
            <doc xml:space="preserve">a #StShadow</doc>
            <type name="Shadow" c:type="StShadow*"/>
          </instance-parameter>
          <parameter name="actor_box" transfer-ownership="none">
            <doc xml:space="preserve">the box allocated to a #ClutterAlctor</doc>
            <type name="Clutter.ActorBox" c:type="const ClutterActorBox*"/>
          </parameter>
          <parameter name="shadow_box" transfer-ownership="none">
            <doc xml:space="preserve">computed box occupied by @shadow</doc>
            <type name="Clutter.ActorBox" c:type="ClutterActorBox*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="st_shadow_ref">
        <doc xml:space="preserve">Atomically increments the reference count of @shadow by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #StShadow.</doc>
          <type name="Shadow" c:type="StShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shadow" transfer-ownership="none">
            <doc xml:space="preserve">a #StShadow</doc>
            <type name="Shadow" c:type="StShadow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="st_shadow_unref">
        <doc xml:space="preserve">Atomically decrements the reference count of @shadow by one.
If the reference count drops to 0, all memory allocated by the
#StShadow is released.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shadow" transfer-ownership="none">
            <doc xml:space="preserve">a #StShadow</doc>
            <type name="Shadow" c:type="StShadow*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="ShadowHelper"
            c:type="StShadowHelper"
            glib:type-name="StShadowHelper"
            glib:get-type="st_shadow_helper_get_type"
            c:symbol-prefix="shadow_helper">
      <constructor name="new" c:identifier="st_shadow_helper_new">
        <doc xml:space="preserve">Builds a #StShadowHelper that will build a drop shadow
using @source as the mask.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #StShadowHelper</doc>
          <type name="ShadowHelper" c:type="StShadowHelper*"/>
        </return-value>
        <parameters>
          <parameter name="shadow" transfer-ownership="none">
            <doc xml:space="preserve">a #StShadow representing the shadow properties</doc>
            <type name="Shadow" c:type="StShadow*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="st_shadow_helper_copy">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @helper</doc>
          <type name="ShadowHelper" c:type="StShadowHelper*"/>
        </return-value>
        <parameters>
          <instance-parameter name="helper" transfer-ownership="none">
            <doc xml:space="preserve">the #StShadowHelper to copy</doc>
            <type name="ShadowHelper" c:type="StShadowHelper*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="st_shadow_helper_free">
        <doc xml:space="preserve">Free resources associated with @helper.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="helper" transfer-ownership="none">
            <doc xml:space="preserve">a #StShadowHelper</doc>
            <type name="ShadowHelper" c:type="StShadowHelper*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="paint" c:identifier="st_shadow_helper_paint">
        <doc xml:space="preserve">Paints the shadow associated with @helper This must only
be called from the implementation of ClutterActor::paint().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="helper" transfer-ownership="none">
            <doc xml:space="preserve">a #StShadowHelper</doc>
            <type name="ShadowHelper" c:type="StShadowHelper*"/>
          </instance-parameter>
          <parameter name="actor_box" transfer-ownership="none">
            <doc xml:space="preserve">the bounding box of the shadow</doc>
            <type name="Clutter.ActorBox" c:type="ClutterActorBox*"/>
          </parameter>
          <parameter name="paint_opacity" transfer-ownership="none">
            <doc xml:space="preserve">the opacity at which the shadow is painted</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="st_shadow_helper_update">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="helper" transfer-ownership="none">
            <type name="ShadowHelper" c:type="StShadowHelper*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="Side"
                 glib:type-name="StSide"
                 glib:get-type="st_side_get_type"
                 c:type="StSide">
      <member name="top" value="0" c:identifier="ST_SIDE_TOP" glib:nick="top">
      </member>
      <member name="right"
              value="1"
              c:identifier="ST_SIDE_RIGHT"
              glib:nick="right">
      </member>
      <member name="bottom"
              value="2"
              c:identifier="ST_SIDE_BOTTOM"
              glib:nick="bottom">
      </member>
      <member name="left"
              value="3"
              c:identifier="ST_SIDE_LEFT"
              glib:nick="left">
      </member>
    </enumeration>
    <enumeration name="TextAlign"
                 glib:type-name="StTextAlign"
                 glib:get-type="st_text_align_get_type"
                 c:type="StTextAlign">
      <member name="left"
              value="0"
              c:identifier="ST_TEXT_ALIGN_LEFT"
              glib:nick="left">
      </member>
      <member name="center"
              value="1"
              c:identifier="ST_TEXT_ALIGN_CENTER"
              glib:nick="center">
      </member>
      <member name="right"
              value="2"
              c:identifier="ST_TEXT_ALIGN_RIGHT"
              glib:nick="right">
      </member>
      <member name="justify"
              value="3"
              c:identifier="ST_TEXT_ALIGN_JUSTIFY"
              glib:nick="justify">
      </member>
    </enumeration>
    <bitfield name="TextDecoration"
              glib:type-name="StTextDecoration"
              glib:get-type="st_text_decoration_get_type"
              c:type="StTextDecoration">
      <member name="underline"
              value="1"
              c:identifier="ST_TEXT_DECORATION_UNDERLINE"
              glib:nick="underline">
      </member>
      <member name="overline"
              value="2"
              c:identifier="ST_TEXT_DECORATION_OVERLINE"
              glib:nick="overline">
      </member>
      <member name="line_through"
              value="4"
              c:identifier="ST_TEXT_DECORATION_LINE_THROUGH"
              glib:nick="line-through">
      </member>
      <member name="blink"
              value="8"
              c:identifier="ST_TEXT_DECORATION_BLINK"
              glib:nick="blink">
      </member>
    </bitfield>
    <class name="TextureCache"
           c:symbol-prefix="texture_cache"
           c:type="StTextureCache"
           parent="GObject.Object"
           glib:type-name="StTextureCache"
           glib:get-type="st_texture_cache_get_type"
           glib:type-struct="TextureCacheClass">
      <function name="get_default" c:identifier="st_texture_cache_get_default">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The global texture cache</doc>
          <type name="TextureCache" c:type="StTextureCache*"/>
        </return-value>
      </function>
      <method name="bind_cairo_surface_property"
              c:identifier="st_texture_cache_bind_cairo_surface_property">
        <doc xml:space="preserve">Create a #ClutterTexture which tracks the #cairo_surface_t value of a GObject property
named by @property_name.  Unlike other methods in StTextureCache, the underlying
#CoglTexture is not shared by default with other invocations to this method.

If the source object is destroyed, the texture will continue to show the last
value of the property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #ClutterActor</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <type name="TextureCache" c:type="StTextureCache*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GObject with a property @property_name of type #GdkPixbuf</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of a property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load"
              c:identifier="st_texture_cache_load"
              introspectable="0"
              throws="1">
        <doc xml:space="preserve">Load an arbitrary texture, caching it.  The string chosen for @key
should be of the form "type-prefix:type-uuid".  For example,
"url:file:///usr/share/icons/hicolor/48x48/apps/firefox.png", or
"stock-icon:gtk-ok".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly-referenced handle to the texture</doc>
          <type name="Cogl.Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">A #StTextureCache</doc>
            <type name="TextureCache" c:type="StTextureCache*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary string used to refer to item</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">Caching policy</doc>
            <type name="TextureCachePolicy" c:type="StTextureCachePolicy"/>
          </parameter>
          <parameter name="load" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">Function to create the texture, if not already cached</doc>
            <type name="TextureCacheLoader" c:type="StTextureCacheLoader"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">User data passed to @load</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_file_async"
              c:identifier="st_texture_cache_load_file_async">
        <doc xml:space="preserve">Asynchronously load an image.   Initially, the returned texture will have a natural
size of zero.  At some later point, either the image will be loaded successfully
and at that point size will be negotiated, or upon an error, no image will be set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #ClutterActor with no image loaded initially.</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">The texture cache instance</doc>
            <type name="TextureCache" c:type="StTextureCache*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile of the image file from which to create a pixbuf</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="available_width" transfer-ownership="none">
            <doc xml:space="preserve">available width for the image, can be -1 if not limited</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="available_height" transfer-ownership="none">
            <doc xml:space="preserve">available height for the image, can be -1 if not limited</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">scale factor of the display</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_file_to_cairo_surface"
              c:identifier="st_texture_cache_load_file_to_cairo_surface">
        <doc xml:space="preserve">This function synchronously loads the given file path
into a cairo surface.  On error, a warning is emitted
and %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #cairo_surface_t</doc>
          <type name="cairo.Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">A #StTextureCache</doc>
            <type name="TextureCache" c:type="StTextureCache*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">A #GFile in supported image format</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">Scale factor of the display</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_file_to_cogl_texture"
              c:identifier="st_texture_cache_load_file_to_cogl_texture"
              introspectable="0">
        <doc xml:space="preserve">This function synchronously loads the given file path
into a COGL texture.  On error, a warning is emitted
and %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CoglTexture</doc>
          <type name="Cogl.Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">A #StTextureCache</doc>
            <type name="TextureCache" c:type="StTextureCache*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">A #GFile in supported image format</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">Scale factor of the display</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_gicon" c:identifier="st_texture_cache_load_gicon">
        <doc xml:space="preserve">This method returns a new #ClutterActor for a given #GIcon. If the
icon isn't loaded already, the texture will be filled
asynchronously.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #ClutterActor for the icon, or %NULL if not found</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">The texture cache instance</doc>
            <type name="TextureCache" c:type="StTextureCache*"/>
          </instance-parameter>
          <parameter name="theme_node"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The #StThemeNode to use for colors, or NULL
                           if the icon must not be recolored</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">the #GIcon to load</doc>
            <type name="Gio.Icon" c:type="GIcon*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">Size of themed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">Scale factor of display</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_sliced_image"
              c:identifier="st_texture_cache_load_sliced_image">
        <doc xml:space="preserve">This function reads a single image file which contains multiple images internally.
The image file will be divided using @grid_width and @grid_height;
note that the dimensions of the image loaded from @path
should be a multiple of the specified grid dimensions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #ClutterActor</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">A #StTextureCache</doc>
            <type name="TextureCache" c:type="StTextureCache*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">A #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="grid_width" transfer-ownership="none">
            <doc xml:space="preserve">Width in pixels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="grid_height" transfer-ownership="none">
            <doc xml:space="preserve">Height in pixels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">Scale factor of the display</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="load_callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">Function called when the image is loaded, or %NULL</doc>
            <type name="GLib.Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Data to pass to the load callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="TextureCachePrivate" c:type="StTextureCachePrivate*"/>
      </field>
      <glib:signal name="icon-theme-changed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="texture-file-changed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Gio.File"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TextureCacheClass"
            c:type="StTextureCacheClass"
            glib:is-gtype-struct-for="TextureCache">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <callback name="TextureCacheLoader"
              c:type="StTextureCacheLoader"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">See st_texture_cache_load().  Implementations should return a
texture handle for the given key, or set @error.</doc>
      <return-value>
        <type name="Cogl.Texture" c:type="CoglTexture*"/>
      </return-value>
      <parameters>
        <parameter name="cache" transfer-ownership="none">
          <doc xml:space="preserve">a #StTextureCache</doc>
          <type name="TextureCache" c:type="StTextureCache*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">Unique identifier for this texture</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Callback user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TextureCachePolicy"
                 glib:type-name="StTextureCachePolicy"
                 glib:get-type="st_texture_cache_policy_get_type"
                 c:type="StTextureCachePolicy">
      <member name="none"
              value="0"
              c:identifier="ST_TEXTURE_CACHE_POLICY_NONE"
              glib:nick="none">
      </member>
      <member name="forever"
              value="1"
              c:identifier="ST_TEXTURE_CACHE_POLICY_FOREVER"
              glib:nick="forever">
      </member>
    </enumeration>
    <record name="TextureCachePrivate"
            c:type="StTextureCachePrivate"
            disguised="1">
    </record>
    <class name="Theme"
           c:symbol-prefix="theme"
           c:type="StTheme"
           parent="GObject.Object"
           glib:type-name="StTheme"
           glib:get-type="st_theme_get_type"
           glib:type-struct="ThemeClass">
      <constructor name="new" c:identifier="st_theme_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created theme object</doc>
          <type name="Theme" c:type="StTheme*"/>
        </return-value>
        <parameters>
          <parameter name="application_stylesheet" transfer-ownership="none">
            <doc xml:space="preserve">The highest priority stylesheet, representing application-specific
  styling; this is associated with the CSS "author" stylesheet, may be %NULL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="theme_stylesheet" transfer-ownership="none">
            <doc xml:space="preserve">The second priority stylesheet, representing theme-specific styling ;
  this is associated with the CSS "user" stylesheet, may be %NULL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="default_stylesheet" transfer-ownership="none">
            <doc xml:space="preserve">The lowest priority stylesheet, representing global default styling;
  this is associated with the CSS "user agent" stylesheet, may be %NULL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_custom_stylesheets"
              c:identifier="st_theme_get_custom_stylesheets">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the list of stylesheet files
         that were loaded with st_theme_load_stylesheet()</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Gio.File"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="theme" transfer-ownership="none">
            <doc xml:space="preserve">an #StTheme</doc>
            <type name="Theme" c:type="StTheme*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_stylesheet"
              c:identifier="st_theme_load_stylesheet"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="theme" transfer-ownership="none">
            <type name="Theme" c:type="StTheme*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unload_stylesheet"
              c:identifier="st_theme_unload_stylesheet">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="theme" transfer-ownership="none">
            <type name="Theme" c:type="StTheme*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <property name="application-stylesheet"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The highest priority stylesheet, representing application-specific
styling; this is associated with the CSS "author" stylesheet.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="default-stylesheet"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The lowest priority stylesheet, representing global default
styling; this is associated with the CSS "user agent" stylesheet.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="theme-stylesheet"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The second priority stylesheet, representing theme-specific styling;
this is associated with the CSS "user" stylesheet.</doc>
        <type name="Gio.File"/>
      </property>
      <glib:signal name="custom-stylesheets-changed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ThemeClass"
            c:type="StThemeClass"
            glib:is-gtype-struct-for="Theme">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="ThemeContext"
           c:symbol-prefix="theme_context"
           c:type="StThemeContext"
           parent="GObject.Object"
           glib:type-name="StThemeContext"
           glib:get-type="st_theme_context_get_type"
           glib:type-struct="ThemeContextClass">
      <constructor name="new" c:identifier="st_theme_context_new">
        <doc xml:space="preserve">Create a new theme context not associated with any #ClutterStage.
This can be useful in testing scenarios, or if using StThemeContext
with something other than #ClutterActor objects, but you generally
should use st_theme_context_get_for_stage() instead.</doc>
        <return-value transfer-ownership="full">
          <type name="ThemeContext" c:type="StThemeContext*"/>
        </return-value>
      </constructor>
      <function name="get_for_stage"
                c:identifier="st_theme_context_get_for_stage">
        <doc xml:space="preserve">Gets a singleton theme context associated with the stage.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the singleton theme context for the stage</doc>
          <type name="ThemeContext" c:type="StThemeContext*"/>
        </return-value>
        <parameters>
          <parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #ClutterStage</doc>
            <type name="Clutter.Stage" c:type="ClutterStage*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_font" c:identifier="st_theme_context_get_font">
        <doc xml:space="preserve">Gets the default font for the theme context. See st_theme_context_set_font().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default font for the theme context.</doc>
          <type name="Pango.FontDescription"
                c:type="const PangoFontDescription*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeContext</doc>
            <type name="ThemeContext" c:type="StThemeContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root_node"
              c:identifier="st_theme_context_get_root_node">
        <doc xml:space="preserve">Gets the root node of the tree of theme style nodes that associated with this
context. For the node tree associated with a stage, this node represents
styles applied to the stage itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the root node of the context's style tree</doc>
          <type name="ThemeNode" c:type="StThemeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeContext</doc>
            <type name="ThemeContext" c:type="StThemeContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_theme" c:identifier="st_theme_context_get_theme">
        <doc xml:space="preserve">Gets the default theme for the context. See st_theme_context_set_theme()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default theme for the context</doc>
          <type name="Theme" c:type="StTheme*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeContext</doc>
            <type name="ThemeContext" c:type="StThemeContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="intern_node" c:identifier="st_theme_context_intern_node">
        <doc xml:space="preserve">Return an existing node matching @node, or if that isn't possible,
@node itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a node with the same properties as @node</doc>
          <type name="ThemeNode" c:type="StThemeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeContext</doc>
            <type name="ThemeContext" c:type="StThemeContext*"/>
          </instance-parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_font" c:identifier="st_theme_context_set_font">
        <doc xml:space="preserve">Sets the default font for the theme context. This is the font that
is inherited by the root node of the tree of theme nodes. If the
font is not overriden, then this font will be used. If the font is
partially modified (for example, with 'font-size: 110%', then that
modification is based on this font.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeContext</doc>
            <type name="ThemeContext" c:type="StThemeContext*"/>
          </instance-parameter>
          <parameter name="font" transfer-ownership="none">
            <doc xml:space="preserve">the default font for theme context</doc>
            <type name="Pango.FontDescription"
                  c:type="const PangoFontDescription*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_theme" c:identifier="st_theme_context_set_theme">
        <doc xml:space="preserve">Sets the default set of theme stylesheets for the context. This theme will
be used for the root node and for nodes descending from it, unless some other
style is explicitely specified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeContext</doc>
            <type name="ThemeContext" c:type="StThemeContext*"/>
          </instance-parameter>
          <parameter name="theme" transfer-ownership="none">
            <type name="Theme" c:type="StTheme*"/>
          </parameter>
        </parameters>
      </method>
      <property name="scale-factor" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The scaling factor used or high dpi scaling.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <glib:signal name="changed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ThemeContextClass"
            c:type="StThemeContextClass"
            glib:is-gtype-struct-for="ThemeContext">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="ThemeNode"
           c:symbol-prefix="theme_node"
           c:type="StThemeNode"
           parent="GObject.Object"
           glib:type-name="StThemeNode"
           glib:get-type="st_theme_node_get_type"
           glib:type-struct="ThemeNodeClass">
      <constructor name="new" c:identifier="st_theme_node_new">
        <doc xml:space="preserve">Creates a new #StThemeNode. Once created, a node is immutable. Of any
of the attributes of the node (like the @element_class) change the node
and its child nodes must be destroyed and recreated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the theme node</doc>
          <type name="ThemeNode" c:type="StThemeNode*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">the context representing global state for this themed tree</doc>
            <type name="ThemeContext" c:type="StThemeContext*"/>
          </parameter>
          <parameter name="parent_node"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the parent node of this node</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
          <parameter name="theme"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a theme (stylesheet set) that overrides the
  theme inherited from the parent node</doc>
            <type name="Theme" c:type="StTheme*"/>
          </parameter>
          <parameter name="element_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of the GObject represented by this node
 in the tree (corresponding to an element if we were theming an XML
 document. %G_TYPE_NONE means this style was created for the stage
actor and matches a selector element name of 'stage'.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="element_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the ID to match CSS rules against</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="element_class"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a whitespace-separated list of classes
  to match CSS rules against</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pseudo_class"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a whitespace-separated list of pseudo-classes
  (like 'hover' or 'visited') to match CSS rules against</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="inline_style" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="adjust_for_height"
              c:identifier="st_theme_node_adjust_for_height">
        <doc xml:space="preserve">Adjusts a "for height" passed to clutter_actor_get_preferred_width() to
account for borders and padding. This is a convenience function meant
to be called from a get_preferred_width() method of a #ClutterActor
subclass. The value after adjustment is the height available for the actor's
content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="for_height"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the "for height" to adjust</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="adjust_for_width"
              c:identifier="st_theme_node_adjust_for_width">
        <doc xml:space="preserve">Adjusts a "for width" passed to clutter_actor_get_preferred_height() to
account for borders and padding. This is a convenience function meant
to be called from a get_preferred_height() method of a #ClutterActor
subclass. The value after adjustment is the width available for the actor's
content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="for_width"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the "for width" to adjust</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="adjust_preferred_height"
              c:identifier="st_theme_node_adjust_preferred_height">
        <doc xml:space="preserve">Adjusts the minimum and natural height computed for an actor by
adding on the necessary space for borders and padding and taking
into account any minimum or maximum height. This is a convenience
function meant to be called from the get_preferred_height() method
of a #ClutterActor subclass</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="min_height_p"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the minimum height to adjust</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="natural_height_p"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the natural height to adjust</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="adjust_preferred_width"
              c:identifier="st_theme_node_adjust_preferred_width">
        <doc xml:space="preserve">Adjusts the minimum and natural width computed for an actor by
adding on the necessary space for borders and padding and taking
into account any minimum or maximum width. This is a convenience
function meant to be called from the get_preferred_width() method
of a #ClutterActor subclass</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="min_width_p"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the minimum width to adjust</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="natural_width_p"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the natural width to adjust</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="st_theme_node_equal">
        <doc xml:space="preserve">Compare two #StThemeNodes. Two nodes which compare equal will match
the same CSS rules and have the same style properties. However, two
nodes that have ended up with identical style properties do not
necessarily compare equal.
In detail, @node_a and @node_b are considered equal iff
&lt;itemizedlist&gt;
  &lt;listitem&gt;
    &lt;para&gt;they share the same #StTheme and #StThemeContext&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;they have the same parent&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;they have the same element type&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;their id, class, pseudo-class and inline-style match&lt;/para&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @node_a equals @node_b</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node_a" transfer-ownership="none">
            <doc xml:space="preserve">first #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="node_b" transfer-ownership="none">
            <doc xml:space="preserve">second #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="geometry_equal"
              c:identifier="st_theme_node_geometry_equal">
        <doc xml:space="preserve">Tests if two theme nodes have the same borders and padding; this can be
used to optimize having to relayout when the style applied to a Clutter
actor changes colors without changing the geometry.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">a different #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_background_color"
              c:identifier="st_theme_node_get_background_color">
        <doc xml:space="preserve">Gets @node's background color.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">location to store the color</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_background_gradient"
              c:identifier="st_theme_node_get_background_gradient">
        <doc xml:space="preserve">The @start and @end arguments will only be set if @type is not #ST_GRADIENT_NONE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">A #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Type of gradient</doc>
            <type name="GradientType" c:type="StGradientType*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">Color at start of gradient</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
          <parameter name="end"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">Color at end of gradient</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_background_image"
              c:identifier="st_theme_node_get_background_image">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@node's background image.</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_background_image_shadow"
              c:identifier="st_theme_node_get_background_image_shadow">
        <doc xml:space="preserve">Gets the value for the -st-background-image-shadow style property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the node's background image shadow, or %NULL
  if node has no such shadow</doc>
          <type name="Shadow" c:type="StShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_background_paint_box"
              c:identifier="st_theme_node_get_background_paint_box">
        <doc xml:space="preserve">Gets the box used to paint the actor's background, including the area
occupied by properties which paint outside the actor's assigned allocation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="allocation" transfer-ownership="none">
            <doc xml:space="preserve">the box allocated to a #ClutterActor</doc>
            <type name="Clutter.ActorBox" c:type="const ClutterActorBox*"/>
          </parameter>
          <parameter name="paint_box"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">computed box occupied when painting the actor's background</doc>
            <type name="Clutter.ActorBox" c:type="ClutterActorBox*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_border_color"
              c:identifier="st_theme_node_get_border_color">
        <doc xml:space="preserve">Gets the color of @node's border on @side</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="side" transfer-ownership="none">
            <doc xml:space="preserve">a #StSide</doc>
            <type name="Side" c:type="StSide"/>
          </parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">location to store the color</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_border_image"
              c:identifier="st_theme_node_get_border_image">
        <doc xml:space="preserve">Gets the value for the border-image style property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the border image, or %NULL
  if there is no border image.</doc>
          <type name="BorderImage" c:type="StBorderImage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_border_radius"
              c:identifier="st_theme_node_get_border_radius">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="corner" transfer-ownership="none">
            <type name="Corner" c:type="StCorner"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_border_width"
              c:identifier="st_theme_node_get_border_width">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="side" transfer-ownership="none">
            <type name="Side" c:type="StSide"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_box_shadow"
              c:identifier="st_theme_node_get_box_shadow">
        <doc xml:space="preserve">Gets the value for the box-shadow style property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the node's shadow, or %NULL
  if node has no shadow</doc>
          <type name="Shadow" c:type="StShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color" c:identifier="st_theme_node_get_color">
        <doc xml:space="preserve">Generically looks up a property containing a single color value. When
specific getters (like st_theme_node_get_background_color()) exist, they
should be used instead. They are cached, so more efficient, and have
handling for shortcut properties and other details of CSS.

If @property_name is not found, a warning will be logged and a
default color returned.

See also st_theme_node_lookup_color(), which provides more options,
and lets you handle the case where the theme does not specify the
indicated color.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the color property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">location to store the color that
  was determined.</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_box"
              c:identifier="st_theme_node_get_content_box">
        <doc xml:space="preserve">Gets the box within an actor's allocation that contents the content
of an actor (excluding borders and padding). This is a convenience function
meant to be used from the allocate() or paint() methods of a #ClutterActor
subclass.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="allocation" transfer-ownership="none">
            <doc xml:space="preserve">the box allocated to a #ClutterAlctor</doc>
            <type name="Clutter.ActorBox" c:type="const ClutterActorBox*"/>
          </parameter>
          <parameter name="content_box"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">computed box occupied by the actor's content</doc>
            <type name="Clutter.ActorBox" c:type="ClutterActorBox*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="st_theme_node_get_double">
        <doc xml:space="preserve">Generically looks up a property containing a single numeric value
 without units.

See also st_theme_node_lookup_double(), which provides more options,
and lets you handle the case where the theme does not specify the
indicated value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value found. If @property_name is not
 found, a warning will be logged and 0 will be returned.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the numeric property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_element_classes"
              c:identifier="st_theme_node_get_element_classes">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the element's classes</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_element_id"
              c:identifier="st_theme_node_get_element_id">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_element_type"
              c:identifier="st_theme_node_get_element_type">
        <return-value transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_font" c:identifier="st_theme_node_get_font">
        <return-value transfer-ownership="none">
          <type name="Pango.FontDescription"
                c:type="const PangoFontDescription*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_foreground_color"
              c:identifier="st_theme_node_get_foreground_color">
        <doc xml:space="preserve">Gets @node's foreground color.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">location to store the color</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="st_theme_node_get_height">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_horizontal_padding"
              c:identifier="st_theme_node_get_horizontal_padding">
        <doc xml:space="preserve">Gets the total horizonal padding (left + right padding)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the total horizonal padding
  in pixels</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon_colors"
              c:identifier="st_theme_node_get_icon_colors">
        <doc xml:space="preserve">Gets the colors that should be used for colorizing symbolic icons according
the style of this node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the icon colors to use for this theme node</doc>
          <type name="IconColors" c:type="StIconColors*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon_style"
              c:identifier="st_theme_node_get_icon_style">
        <return-value transfer-ownership="none">
          <type name="IconStyle" c:type="StIconStyle"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="st_theme_node_get_length">
        <doc xml:space="preserve">Generically looks up a property containing a single length value. When
specific getters (like st_theme_node_get_border_width()) exist, they
should be used instead. They are cached, so more efficient, and have
handling for shortcut properties and other details of CSS.

Unlike st_theme_node_get_color() and st_theme_node_get_double(),
this does not print a warning if the property is not found; it just
returns 0.

See also st_theme_node_lookup_length(), which provides more options.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length, in pixels, or 0 if the property was not found.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the length property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_margin" c:identifier="st_theme_node_get_margin">
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="side" transfer-ownership="none">
            <type name="Side" c:type="StSide"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_height"
              c:identifier="st_theme_node_get_max_height">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_width" c:identifier="st_theme_node_get_max_width">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_height"
              c:identifier="st_theme_node_get_min_height">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_width" c:identifier="st_theme_node_get_min_width">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outline_color"
              c:identifier="st_theme_node_get_outline_color">
        <doc xml:space="preserve">Gets the color of @node's outline.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">location to store the color</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_outline_width"
              c:identifier="st_theme_node_get_outline_width">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_padding" c:identifier="st_theme_node_get_padding">
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="side" transfer-ownership="none">
            <type name="Side" c:type="StSide"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_paint_box" c:identifier="st_theme_node_get_paint_box">
        <doc xml:space="preserve">Gets the box used to paint the actor, including the area occupied
by properties which paint outside the actor's assigned allocation.
When painting @node to an offscreen buffer, this function can be
used to determine the necessary size of the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="allocation" transfer-ownership="none">
            <doc xml:space="preserve">the box allocated to a #ClutterActor</doc>
            <type name="Clutter.ActorBox" c:type="const ClutterActorBox*"/>
          </parameter>
          <parameter name="paint_box"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">computed box occupied when painting the actor</doc>
            <type name="Clutter.ActorBox" c:type="ClutterActorBox*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="st_theme_node_get_parent">
        <doc xml:space="preserve">Gets the parent themed element node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parent #StThemeNode, or %NULL if this
 is the root node of the tree of theme elements.</doc>
          <type name="ThemeNode" c:type="StThemeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pseudo_classes"
              c:identifier="st_theme_node_get_pseudo_classes">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the element's pseudo-classes</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shadow" c:identifier="st_theme_node_get_shadow">
        <doc xml:space="preserve">Generically looks up a property containing a set of shadow values. When
specific getters (like st_theme_node_get_box_shadow()) exist, they
should be used instead. They are cached, so more efficient, and have
handling for shortcut properties and other details of CSS.

Like st_theme_get_length(), this does not print a warning if the property is
not found; it just returns %NULL

See also st_theme_node_lookup_shadow (), which provides more options.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the shadow, or %NULL if the property was not found.</doc>
          <type name="Shadow" c:type="StShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the shadow property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_text_align"
              c:identifier="st_theme_node_get_text_align">
        <return-value transfer-ownership="none">
          <type name="TextAlign" c:type="StTextAlign"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_text_decoration"
              c:identifier="st_theme_node_get_text_decoration">
        <return-value transfer-ownership="none">
          <type name="TextDecoration" c:type="StTextDecoration"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_text_shadow"
              c:identifier="st_theme_node_get_text_shadow">
        <doc xml:space="preserve">Gets the value for the text-shadow style property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the node's text-shadow, or %NULL
  if node has no text-shadow</doc>
          <type name="Shadow" c:type="StShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_theme" c:identifier="st_theme_node_get_theme">
        <doc xml:space="preserve">Gets the theme stylesheet set that styles this node</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the theme stylesheet set</doc>
          <type name="Theme" c:type="StTheme*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_transition_duration"
              c:identifier="st_theme_node_get_transition_duration">
        <doc xml:space="preserve">Get the value of the transition-duration property, which
specifies the transition time between the previous #StThemeNode
and @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the node's transition duration in milliseconds</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">an #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_url" c:identifier="st_theme_node_get_url">
        <doc xml:space="preserve">Looks up a property containing a single URL value.

See also st_theme_node_lookup_url(), which provides more options,
and lets you handle the case where the theme does not specify the
indicated value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated value if found.
 If @property_name is not found, a warning will be logged and %NULL
 will be returned.</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the string property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vertical_padding"
              c:identifier="st_theme_node_get_vertical_padding">
        <doc xml:space="preserve">Gets the total vertical padding (top + bottom padding)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the total vertical padding
  in pixels</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="st_theme_node_get_width">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="st_theme_node_hash">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate_background_image"
              c:identifier="st_theme_node_invalidate_background_image">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate_border_image"
              c:identifier="st_theme_node_invalidate_border_image">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup_color" c:identifier="st_theme_node_lookup_color">
        <doc xml:space="preserve">Generically looks up a property containing a single color value. When
specific getters (like st_theme_node_get_background_color()) exist, they
should be used instead. They are cached, so more efficient, and have
handling for shortcut properties and other details of CSS.

See also st_theme_node_get_color(), which provides a simpler API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the property was found in the properties for this
 theme node (or in the properties of parent nodes when inheriting.)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the color property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="inherit" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, if a value is not found for the property on the
  node, then it will be looked up on the parent node, and then on the
  parent's parent, and so forth. Note that if the property has a
  value of 'inherit' it will be inherited even if %FALSE is passed
  in for @inherit; this only affects the default behavior for inheritance.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">location to store the color that was
  determined. If the property is not found, the value in this location
  will not be changed.</doc>
            <type name="Clutter.Color" c:type="ClutterColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_double" c:identifier="st_theme_node_lookup_double">
        <doc xml:space="preserve">Generically looks up a property containing a single numeric value
 without units.

See also st_theme_node_get_double(), which provides a simpler API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the property was found in the properties for this
 theme node (or in the properties of parent nodes when inheriting.)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the numeric property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="inherit" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, if a value is not found for the property on the
  node, then it will be looked up on the parent node, and then on the
  parent's parent, and so forth. Note that if the property has a
  value of 'inherit' it will be inherited even if %FALSE is passed
  in for @inherit; this only affects the default behavior for inheritance.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store the value that was determined.
  If the property is not found, the value in this location
  will not be changed.</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_length" c:identifier="st_theme_node_lookup_length">
        <doc xml:space="preserve">Generically looks up a property containing a single length value. When
specific getters (like st_theme_node_get_border_width()) exist, they
should be used instead. They are cached, so more efficient, and have
handling for shortcut properties and other details of CSS.

See also st_theme_node_get_length(), which provides a simpler API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the property was found in the properties for this
 theme node (or in the properties of parent nodes when inheriting.)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the length property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="inherit" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, if a value is not found for the property on the
  node, then it will be looked up on the parent node, and then on the
  parent's parent, and so forth. Note that if the property has a
  value of 'inherit' it will be inherited even if %FALSE is passed
  in for @inherit; this only affects the default behavior for inheritance.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store the length that was determined.
  If the property is not found, the value in this location
  will not be changed. The returned length is resolved
  to pixels.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_shadow" c:identifier="st_theme_node_lookup_shadow">
        <doc xml:space="preserve">If the property is not found, the value in the shadow variable will not
be changed.

Generically looks up a property containing a set of shadow values. When
specific getters (like st_theme_node_get_box_shadow ()) exist, they
should be used instead. They are cached, so more efficient, and have
handling for shortcut properties and other details of CSS.

See also st_theme_node_get_shadow(), which provides a simpler API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the property was found in the properties for this
theme node (or in the properties of parent nodes when inheriting.), %FALSE
if the property was not found, or was explicitly set to 'none'.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the shadow property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="inherit" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, if a value is not found for the property on the
  node, then it will be looked up on the parent node, and then on the
  parent's parent, and so forth. Note that if the property has a
  value of 'inherit' it will be inherited even if %FALSE is passed
  in for @inherit; this only affects the default behavior for inheritance.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="shadow"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store the shadow</doc>
            <type name="Shadow" c:type="StShadow**"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_time" c:identifier="st_theme_node_lookup_time">
        <doc xml:space="preserve">Generically looks up a property containing a single time value,
 which is converted to milliseconds.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the property was found in the properties for this
 theme node (or in the properties of parent nodes when inheriting.)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the time property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="inherit" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, if a value is not found for the property on the
  node, then it will be looked up on the parent node, and then on the
  parent's parent, and so forth. Note that if the property has a
  value of 'inherit' it will be inherited even if %FALSE is passed
  in for @inherit; this only affects the default behavior for inheritance.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store the value that was determined.
  If the property is not found, the value in this location
  will not be changed.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_url" c:identifier="st_theme_node_lookup_url">
        <doc xml:space="preserve">Looks up a property containing a single URL value.

See also st_theme_node_get_url(), which provides a simpler API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the property was found in the properties for this
 theme node (or in the properties of parent nodes when inheriting.)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the string property</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="inherit" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, if a value is not found for the property on the
  node, then it will be looked up on the parent node, and then on the
  parent's parent, and so forth. Note that if the property has a
  value of 'inherit' it will be inherited even if %FALSE is passed
  in for @inherit; this only affects the default behavior for inheritance.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="file"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store the newly allocated value that was
  determined. If the property is not found, the value in this location
  will not be changed.</doc>
            <type name="Gio.File" c:type="GFile**"/>
          </parameter>
        </parameters>
      </method>
      <method name="paint"
              c:identifier="st_theme_node_paint"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </parameter>
          <parameter name="framebuffer" transfer-ownership="none">
            <type c:type="CoglFramebuffer*"/>
          </parameter>
          <parameter name="box" transfer-ownership="none">
            <type name="Clutter.ActorBox" c:type="const ClutterActorBox*"/>
          </parameter>
          <parameter name="paint_opacity" transfer-ownership="none">
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="paint_equal" c:identifier="st_theme_node_paint_equal">
        <doc xml:space="preserve">Check if st_theme_node_paint() will paint identically for @node as it does
for @other. Note that in some cases this function may return %TRUE even
if there is no visible difference in the painting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the two theme nodes paint identically. %FALSE if the
  two nodes potentially paint differently.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
          <parameter name="other"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a different #StThemeNode</doc>
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="st_theme_node_to_string">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="context">
        <type name="ThemeContext" c:type="StThemeContext*"/>
      </field>
      <field name="parent_node">
        <type name="ThemeNode" c:type="StThemeNode*"/>
      </field>
      <field name="theme">
        <type name="Theme" c:type="StTheme*"/>
      </field>
      <field name="font_desc">
        <type name="Pango.FontDescription" c:type="PangoFontDescription*"/>
      </field>
      <field name="background_color">
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="background_gradient_type">
        <type name="GradientType" c:type="StGradientType"/>
      </field>
      <field name="background_gradient_end">
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="background_position_x">
        <type name="gint" c:type="int"/>
      </field>
      <field name="background_position_y">
        <type name="gint" c:type="int"/>
      </field>
      <field name="background_size">
        <type name="BackgroundSize" c:type="StBackgroundSize"/>
      </field>
      <field name="background_size_w">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="background_size_h">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="foreground_color">
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="border_color">
        <array zero-terminated="0" c:type="ClutterColor" fixed-size="4">
          <type name="Clutter.Color" c:type="ClutterColor"/>
        </array>
      </field>
      <field name="outline_color">
        <type name="Clutter.Color" c:type="ClutterColor"/>
      </field>
      <field name="border_width">
        <array zero-terminated="0" c:type="int" fixed-size="4">
          <type name="gint" c:type="int"/>
        </array>
      </field>
      <field name="border_radius">
        <array zero-terminated="0" c:type="int" fixed-size="4">
          <type name="gint" c:type="int"/>
        </array>
      </field>
      <field name="outline_width">
        <type name="gint" c:type="int"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="guint" fixed-size="4">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="margin">
        <array zero-terminated="0" c:type="guint" fixed-size="4">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="width">
        <type name="gint" c:type="int"/>
      </field>
      <field name="height">
        <type name="gint" c:type="int"/>
      </field>
      <field name="min_width">
        <type name="gint" c:type="int"/>
      </field>
      <field name="min_height">
        <type name="gint" c:type="int"/>
      </field>
      <field name="max_width">
        <type name="gint" c:type="int"/>
      </field>
      <field name="max_height">
        <type name="gint" c:type="int"/>
      </field>
      <field name="transition_duration">
        <type name="gint" c:type="int"/>
      </field>
      <field name="background_image">
        <type name="Gio.File" c:type="GFile*"/>
      </field>
      <field name="border_image">
        <type name="BorderImage" c:type="StBorderImage*"/>
      </field>
      <field name="box_shadow">
        <type name="Shadow" c:type="StShadow*"/>
      </field>
      <field name="background_image_shadow">
        <type name="Shadow" c:type="StShadow*"/>
      </field>
      <field name="text_shadow">
        <type name="Shadow" c:type="StShadow*"/>
      </field>
      <field name="icon_colors">
        <type name="IconColors" c:type="StIconColors*"/>
      </field>
      <field name="element_type">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="element_id">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="element_classes">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="pseudo_classes">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="inline_style">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="properties" introspectable="0">
        <type c:type="CRDeclaration**"/>
      </field>
      <field name="n_properties">
        <type name="gint" c:type="int"/>
      </field>
      <field name="inline_properties" introspectable="0">
        <type c:type="CRDeclaration*"/>
      </field>
      <field name="background_position_set" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="background_repeat" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="properties_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="geometry_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="background_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="foreground_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="border_image_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="box_shadow_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="background_image_shadow_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="text_shadow_computed" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="link_type" bits="2">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="rendered_once" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="cached_textures" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="box_shadow_min_width">
        <type name="gint" c:type="int"/>
      </field>
      <field name="box_shadow_min_height">
        <type name="gint" c:type="int"/>
      </field>
      <field name="border_slices_texture" introspectable="0">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="border_slices_pipeline" introspectable="0">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="background_texture" introspectable="0">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="background_pipeline" introspectable="0">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="background_shadow_pipeline" introspectable="0">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="color_pipeline" introspectable="0">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="cached_state">
        <type name="ThemeNodePaintState" c:type="StThemeNodePaintState"/>
      </field>
    </class>
    <record name="ThemeNodeClass"
            c:type="StThemeNodeClass"
            glib:is-gtype-struct-for="ThemeNode">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ThemeNodePaintState" c:type="StThemeNodePaintState">
      <field name="node" writable="1">
        <type name="ThemeNode" c:type="StThemeNode*"/>
      </field>
      <field name="alloc_width" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="alloc_height" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="box_shadow_width" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="box_shadow_height" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="box_shadow_pipeline" introspectable="0" writable="1">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="prerendered_texture" introspectable="0" writable="1">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="prerendered_pipeline" introspectable="0" writable="1">
        <type c:type="CoglPipeline*"/>
      </field>
      <field name="corner_material" writable="1">
        <array zero-terminated="0" c:type="CoglHandle" fixed-size="4">
          <type name="Cogl.Handle" c:type="CoglHandle"/>
        </array>
      </field>
      <method name="copy" c:identifier="st_theme_node_paint_state_copy">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="st_theme_node_paint_state_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="st_theme_node_paint_state_init">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate"
              c:identifier="st_theme_node_paint_state_invalidate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate_for_file"
              c:identifier="st_theme_node_paint_state_invalidate_for_file">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_node"
              c:identifier="st_theme_node_paint_state_set_node">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </instance-parameter>
          <parameter name="node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="ThemeNodeTransition"
           c:symbol-prefix="theme_node_transition"
           c:type="StThemeNodeTransition"
           parent="GObject.Object"
           glib:type-name="StThemeNodeTransition"
           glib:get-type="st_theme_node_transition_get_type"
           glib:type-struct="ThemeNodeTransitionClass">
      <constructor name="new" c:identifier="st_theme_node_transition_new">
        <return-value transfer-ownership="full">
          <type name="ThemeNodeTransition" c:type="StThemeNodeTransition*"/>
        </return-value>
        <parameters>
          <parameter name="from_node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
          <parameter name="to_node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
          <parameter name="old_paint_state" transfer-ownership="none">
            <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_new_paint_state"
              c:identifier="st_theme_node_transition_get_new_paint_state"
              introspectable="0">
        <return-value>
          <type name="ThemeNodePaintState" c:type="StThemeNodePaintState*"/>
        </return-value>
        <parameters>
          <instance-parameter name="transition" transfer-ownership="none">
            <type name="ThemeNodeTransition" c:type="StThemeNodeTransition*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_paint_box"
              c:identifier="st_theme_node_transition_get_paint_box">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="transition" transfer-ownership="none">
            <type name="ThemeNodeTransition" c:type="StThemeNodeTransition*"/>
          </instance-parameter>
          <parameter name="allocation" transfer-ownership="none">
            <type name="Clutter.ActorBox" c:type="const ClutterActorBox*"/>
          </parameter>
          <parameter name="paint_box" transfer-ownership="none">
            <type name="Clutter.ActorBox" c:type="ClutterActorBox*"/>
          </parameter>
        </parameters>
      </method>
      <method name="paint" c:identifier="st_theme_node_transition_paint">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="transition" transfer-ownership="none">
            <type name="ThemeNodeTransition" c:type="StThemeNodeTransition*"/>
          </instance-parameter>
          <parameter name="allocation" transfer-ownership="none">
            <type name="Clutter.ActorBox" c:type="ClutterActorBox*"/>
          </parameter>
          <parameter name="paint_opacity" transfer-ownership="none">
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="st_theme_node_transition_update">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="transition" transfer-ownership="none">
            <type name="ThemeNodeTransition" c:type="StThemeNodeTransition*"/>
          </instance-parameter>
          <parameter name="new_node" transfer-ownership="none">
            <type name="ThemeNode" c:type="StThemeNode*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="completed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="new-frame" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ThemeNodeTransitionClass"
            c:type="StThemeNodeTransitionClass"
            glib:is-gtype-struct-for="ThemeNodeTransition">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="Widget"
           c:symbol-prefix="widget"
           c:type="StWidget"
           parent="Clutter.Actor"
           glib:type-name="StWidget"
           glib:get-type="st_widget_get_type"
           glib:type-struct="WidgetClass">
      <implements name="Atk.ImplementorIface"/>
      <implements name="Clutter.Animatable"/>
      <implements name="Clutter.Container"/>
      <implements name="Clutter.Scriptable"/>
      <virtual-method name="get_focus_chain" invoker="get_focus_chain">
        <doc xml:space="preserve">Gets a list of the focusable children of @widget, in "Tab"
order. By default, this returns all visible
(as in clutter_actor_is_visible()) children of @widget.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
  @widget's focusable children</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Clutter.Actor"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">An #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="navigate_focus">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the "top level" container</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="from"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the actor that the focus is coming from</doc>
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">the direction focus is moving in</doc>
            <type name="Gtk.DirectionType" c:type="GtkDirectionType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="popup_menu" invoker="popup_menu">
        <doc xml:space="preserve">Asks the widget to pop-up a context menu.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="style_changed" invoker="style_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_accessible_state"
              c:identifier="st_widget_add_accessible_state">
        <doc xml:space="preserve">This method adds @state as one of the accessible states for
@widget. The list of states of a widget describes the current state
of user interface element @widget and is provided so that assistive
technologies know how to present @widget to the user.

Usually you will have no need to add accessible states for an
object, as the accessible object can extract most of the states
from the object itself (ie: a #StButton knows when it is pressed).
This method is only required when one cannot extract the
information automatically from the object itself (i.e.: a generic
container used as a toggle menu item will not automatically include
the toggled state).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">#AtkStateType state to add</doc>
            <type name="Atk.StateType" c:type="AtkStateType"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_style_class_name"
              c:identifier="st_widget_add_style_class_name">
        <doc xml:space="preserve">Adds @style_class to @actor's style class name list, if it is not
already present.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="style_class" transfer-ownership="none">
            <doc xml:space="preserve">a style class name string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_style_pseudo_class"
              c:identifier="st_widget_add_style_pseudo_class">
        <doc xml:space="preserve">Adds @pseudo_class to @actor's pseudo class list, if it is not
already present.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="pseudo_class" transfer-ownership="none">
            <doc xml:space="preserve">a pseudo class string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_style" c:identifier="st_widget_ensure_style">
        <doc xml:space="preserve">Ensures that @widget has read its style information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_accessible_name"
              c:identifier="st_widget_get_accessible_name">
        <doc xml:space="preserve">Gets the accessible name for this widget. See
st_widget_set_accessible_name() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a character string representing the accessible name
of the widget.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">widget to get the accessible name for</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_accessible_role"
              c:identifier="st_widget_get_accessible_role">
        <doc xml:space="preserve">Gets the #AtkRole for this widget. See
st_widget_set_accessible_role() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">accessible #AtkRole for this widget</doc>
          <type name="Atk.Role" c:type="AtkRole"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">widget to get the accessible role for</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_can_focus" c:identifier="st_widget_get_can_focus">
        <doc xml:space="preserve">Returns the current value of the can-focus property. See
st_widget_set_can_focus() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">current value of can-focus on @widget</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_focus_chain" c:identifier="st_widget_get_focus_chain">
        <doc xml:space="preserve">Gets a list of the focusable children of @widget, in "Tab"
order. By default, this returns all visible
(as in clutter_actor_is_visible()) children of @widget.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
  @widget's focusable children</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Clutter.Actor"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">An #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hover" c:identifier="st_widget_get_hover">
        <doc xml:space="preserve">If #StWidget:track-hover is set, this returns whether the pointer
is currently over the widget.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">current value of hover on @widget</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_label_actor" c:identifier="st_widget_get_label_actor">
        <doc xml:space="preserve">Gets the label that identifies @widget if it is defined</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the label that identifies the widget</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_style" c:identifier="st_widget_get_style">
        <doc xml:space="preserve">Get the current inline style string. See st_widget_set_style().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The inline style string, or %NULL. The string is owned by the
#StWidget and should not be modified or freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_style_class_name"
              c:identifier="st_widget_get_style_class_name">
        <doc xml:space="preserve">Get the current style class name</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the class name string. The string is owned by the #StWidget and
should not be modified or freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_style_pseudo_class"
              c:identifier="st_widget_get_style_pseudo_class">
        <doc xml:space="preserve">Get the current style pseudo class list.

Note that an actor can have multiple pseudo classes; if you just
want to test for the presence of a specific pseudo class, use
st_widget_has_style_pseudo_class().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the pseudo class list string. The string is owned by the
#StWidget and should not be modified or freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_theme" c:identifier="st_widget_get_theme">
        <doc xml:space="preserve">Gets the overriding theme set on the actor. See st_widget_set_theme()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the overriding theme, or %NULL</doc>
          <type name="Theme" c:type="StTheme*"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_theme_node" c:identifier="st_widget_get_theme_node">
        <doc xml:space="preserve">Gets the theme node holding style information for the widget.
The theme node is used to access standard and custom CSS
properties of the widget.

Note: it is a fatal error to call this on a widget that is
 not been added to a stage.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the theme node for the widget.
  This is owned by the widget. When attributes of the widget
  or the environment that affect the styling change (for example
  the style_class property of the widget), it will be recreated,
  and the ::style-changed signal will be emitted on the widget.</doc>
          <type name="ThemeNode" c:type="StThemeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_track_hover" c:identifier="st_widget_get_track_hover">
        <doc xml:space="preserve">Returns the current value of the track-hover property. See
st_widget_set_track_hover() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">current value of track-hover on @widget</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_style_class_name"
              c:identifier="st_widget_has_style_class_name">
        <doc xml:space="preserve">Tests if @actor's style class list includes @style_class.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @actor's style class list includes
@style_class.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="style_class" transfer-ownership="none">
            <doc xml:space="preserve">a style class string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_style_pseudo_class"
              c:identifier="st_widget_has_style_pseudo_class">
        <doc xml:space="preserve">Tests if @actor's pseudo class list includes @pseudo_class.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @actor's pseudo class list includes
@pseudo_class.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="pseudo_class" transfer-ownership="none">
            <doc xml:space="preserve">a pseudo class string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="navigate_focus" c:identifier="st_widget_navigate_focus">
        <doc xml:space="preserve">Tries to update the keyboard focus within @widget in response to a
keyboard event.

If @from is a descendant of @widget, this attempts to move the
keyboard focus to the next descendant of @widget (in the order
implied by @direction) that has the #StWidget:can-focus property
set. If @from is %NULL, this attempts to focus either @widget
itself, or its first descendant in the order implied by
@direction. If @from is outside of @widget, it behaves as if it was
a descendant if @direction is one of the directional arrows and as
if it was %NULL otherwise.

If a container type is marked #StWidget:can-focus, the expected
behavior is that it will only take up a single slot on the focus
chain as a whole, rather than allowing navigation between its child
actors (or having a distinction between itself being focused and
one of its children being focused).

Some widget classes might have slightly different behavior from the
above, where that would make more sense.

If @wrap_around is %TRUE and @from is a child of @widget, but the
widget has no further children that can accept the focus in the
given direction, then st_widget_navigate_focus() will try a second
time, using a %NULL @from, which should cause it to reset the focus
to the first available widget in the given direction.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if clutter_actor_grab_key_focus() has been
called on an actor. %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">the "top level" container</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="from"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the actor that the focus is coming from</doc>
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">the direction focus is moving in</doc>
            <type name="Gtk.DirectionType" c:type="GtkDirectionType"/>
          </parameter>
          <parameter name="wrap_around" transfer-ownership="none">
            <doc xml:space="preserve">whether focus should wrap around</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="paint_background"
              c:identifier="st_widget_paint_background">
        <doc xml:space="preserve">Paint the background of the widget. This is meant to be called by
subclasses of StWidget that need to paint the background without
painting children.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">The #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_theme_node" c:identifier="st_widget_peek_theme_node">
        <doc xml:space="preserve">Returns the theme node for the widget if it has already been
computed, %NULL if the widget hasn't been added to a  stage or the theme
node hasn't been computed. If %NULL is returned, then ::style-changed
will be reliably emitted before the widget is allocated or painted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the theme node for the widget.
  This is owned by the widget. When attributes of the widget
  or the environment that affect the styling change (for example
  the style_class property of the widget), it will be recreated,
  and the ::style-changed signal will be emitted on the widget.</doc>
          <type name="ThemeNode" c:type="StThemeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="popup_menu" c:identifier="st_widget_popup_menu">
        <doc xml:space="preserve">Asks the widget to pop-up a context menu.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_accessible_state"
              c:identifier="st_widget_remove_accessible_state">
        <doc xml:space="preserve">This method removes @state as on of the accessible states for
@widget. See st_widget_add_accessible_state() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">#AtkState state to remove</doc>
            <type name="Atk.StateType" c:type="AtkStateType"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_style_class_name"
              c:identifier="st_widget_remove_style_class_name">
        <doc xml:space="preserve">Removes @style_class from @actor's style class name, if it is
present.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="style_class" transfer-ownership="none">
            <doc xml:space="preserve">a style class name string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_style_pseudo_class"
              c:identifier="st_widget_remove_style_pseudo_class">
        <doc xml:space="preserve">Removes @pseudo_class from @actor's pseudo class, if it is present.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="pseudo_class" transfer-ownership="none">
            <doc xml:space="preserve">a pseudo class string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_accessible" c:identifier="st_widget_set_accessible">
        <doc xml:space="preserve">This method allows to set a customly created accessible object to
this widget. For example if you define a new subclass of
#StWidgetAccessible at the javascript code.

NULL is a valid value for @accessible. That contemplates the
hypothetical case of not needing anymore a custom accessible object
for the widget. Next call of st_widget_get_accessible() would
create and return a default accessible.

It assumes that the call to atk_object_initialize that bound the
gobject with the custom accessible object was already called, so
not a responsibility of this method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="accessible" transfer-ownership="none">
            <doc xml:space="preserve">an accessible (#AtkObject)</doc>
            <type name="Atk.Object" c:type="AtkObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_accessible_name"
              c:identifier="st_widget_set_accessible_name">
        <doc xml:space="preserve">This method sets @name as the accessible name for @widget.

Usually you will have no need to set the accessible name for an
object, as usually there is a label for most of the interface
elements. So in general it is better to just use
@st_widget_set_label_actor. This method is only required when you
need to set an accessible name and there is no available label
object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">widget to set the accessible name for</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a character string to be set as the accessible name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_accessible_role"
              c:identifier="st_widget_set_accessible_role">
        <doc xml:space="preserve">This method sets @role as the accessible role for @widget. This
role describes what kind of user interface element @widget is and
is provided so that assistive technologies know how to present
@widget to the user.

Usually you will have no need to set the accessible role for an
object, as this information is extracted from the context of the
object (ie: a #StButton has by default a push button role). This
method is only required when you need to redefine the role
currently associated with the widget, for instance if it is being
used in an unusual way (ie: a #StButton used as a togglebutton), or
if a generic object is used directly (ie: a container as a menu
item).

If @role is #ATK_ROLE_INVALID, the role will not be changed
and the accessible's default role will be used instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">widget to set the accessible role for</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="role" transfer-ownership="none">
            <doc xml:space="preserve">The role to use</doc>
            <type name="Atk.Role" c:type="AtkRole"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_can_focus" c:identifier="st_widget_set_can_focus">
        <doc xml:space="preserve">Marks @widget as being able to receive keyboard focus via
keyboard navigation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="can_focus" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the widget can receive keyboard focus
  via keyboard navigation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hover" c:identifier="st_widget_set_hover">
        <doc xml:space="preserve">Sets @widget's hover property and adds or removes "hover" from its
pseudo class accordingly.

If you have set #StWidget:track-hover, you should not need to call
this directly. You can call st_widget_sync_hover() if the hover
state might be out of sync due to another actor's pointer grab.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="hover" transfer-ownership="none">
            <doc xml:space="preserve">whether the pointer is hovering over the widget</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label_actor" c:identifier="st_widget_set_label_actor">
        <doc xml:space="preserve">Sets @label as the #ClutterActor that identifies (labels)
@widget. @label can be %NULL to indicate that @widget is not
labelled any more</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">a #ClutterActor</doc>
            <type name="Clutter.Actor" c:type="ClutterActor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_style" c:identifier="st_widget_set_style">
        <doc xml:space="preserve">Set the inline style string for this widget. The inline style string is an
optional ';'-separated list of CSS properties that override the style as
determined from the stylesheets of the current theme.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="style"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a inline style string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_style_class_name"
              c:identifier="st_widget_set_style_class_name">
        <doc xml:space="preserve">Set the style class name list. @style_class_list can either be
%NULL, for no classes, or a space-separated list of style class
names. See also st_widget_add_style_class_name() and
st_widget_remove_style_class_name().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="style_class_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a new style class list string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_style_pseudo_class"
              c:identifier="st_widget_set_style_pseudo_class">
        <doc xml:space="preserve">Set the style pseudo class list. @pseudo_class_list can either be
%NULL, for no classes, or a space-separated list of pseudo class
names. See also st_widget_add_style_pseudo_class() and
st_widget_remove_style_pseudo_class().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="pseudo_class_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a new pseudo class list string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_theme" c:identifier="st_widget_set_theme">
        <doc xml:space="preserve">Overrides the theme that would be inherited from the actor's parent
or the stage with an entirely new theme (set of stylesheets).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="actor" transfer-ownership="none">
            <doc xml:space="preserve">a #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="theme" transfer-ownership="none">
            <doc xml:space="preserve">a new style class string</doc>
            <type name="Theme" c:type="StTheme*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_track_hover" c:identifier="st_widget_set_track_hover">
        <doc xml:space="preserve">Enables hover tracking on the #StWidget.

If hover tracking is enabled, and the widget is visible and
reactive, then @widget's #StWidget:hover property will be updated
automatically to reflect whether the pointer is in @widget (or one
of its children), and @widget's #StWidget:pseudo-class will have
the "hover" class added and removed from it accordingly.

Note that currently it is not possible to correctly track the hover
state when another actor has a pointer grab. You can use
st_widget_sync_hover() to update the property manually in this
case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
          <parameter name="track_hover" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the widget should track the pointer hover state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="style_changed" c:identifier="st_widget_style_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sync_hover" c:identifier="st_widget_sync_hover">
        <doc xml:space="preserve">Sets @widget's hover state according to the current pointer
position. This can be used to ensure that it is correct after
(or during) a pointer grab.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="widget" transfer-ownership="none">
            <doc xml:space="preserve">A #StWidget</doc>
            <type name="Widget" c:type="StWidget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="accessible-name" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Object instance's name for assistive technology access.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="accessible-role" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The accessible role of this object</doc>
        <type name="Atk.Role"/>
      </property>
      <property name="can-focus" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the widget can be focused via keyboard navigation.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hover" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the pointer is currently hovering over the widget. This is
only tracked automatically if #StWidget:track-hover is %TRUE, but you can
adjust it manually in any case.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="label-actor" writable="1" transfer-ownership="none">
        <type name="Clutter.Actor"/>
      </property>
      <property name="pseudo-class" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The pseudo-class of the actor. Typical values include "hover", "active",
"focus".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="style" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Inline style information for the actor as a ';'-separated list of
CSS properties.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="style-class" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The style-class of the actor for use in styling.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="theme" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A theme set on this actor overriding the global theming for this actor
and its descendants</doc>
        <type name="Theme"/>
      </property>
      <property name="track-hover" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Determines whether the widget tracks pointer hover state. If
%TRUE (and the widget is visible and reactive), the
#StWidget:hover property and "hover" style pseudo class will be
adjusted automatically as the pointer moves in and out of the
widget.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="Clutter.Actor" c:type="ClutterActor"/>
      </field>
      <glib:signal name="popup-menu" when="last">
        <doc xml:space="preserve">Emitted when the user has requested a context menu (eg, via a
keybinding)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="style-changed" when="last">
        <doc xml:space="preserve">Emitted when the style information that the widget derives from the
theme changes</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <class name="WidgetAccessible"
           c:symbol-prefix="widget_accessible"
           c:type="StWidgetAccessible"
           parent="Cally.Actor"
           glib:type-name="StWidgetAccessible"
           glib:get-type="st_widget_accessible_get_type"
           glib:type-struct="WidgetAccessibleClass">
      <implements name="Atk.Action"/>
      <implements name="Atk.Component"/>
      <field name="parent">
        <type name="Cally.Actor" c:type="CallyActor"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="WidgetAccessiblePrivate"
              c:type="StWidgetAccessiblePrivate*"/>
      </field>
    </class>
    <record name="WidgetAccessibleClass"
            c:type="StWidgetAccessibleClass"
            glib:is-gtype-struct-for="WidgetAccessible">
      <field name="parent_class">
        <type name="Cally.ActorClass" c:type="CallyActorClass"/>
      </field>
    </record>
    <record name="WidgetAccessiblePrivate"
            c:type="StWidgetAccessiblePrivate"
            disguised="1">
    </record>
    <record name="WidgetClass"
            c:type="StWidgetClass"
            glib:is-gtype-struct-for="Widget">
      <doc xml:space="preserve">Base class for stylable actors.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="Clutter.ActorClass" c:type="ClutterActorClass"/>
      </field>
      <field name="style_changed">
        <callback name="style_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Widget" c:type="StWidget*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="popup_menu">
        <callback name="popup_menu">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">A #StWidget</doc>
              <type name="Widget" c:type="StWidget*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="navigate_focus">
        <callback name="navigate_focus">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">the "top level" container</doc>
              <type name="Widget" c:type="StWidget*"/>
            </parameter>
            <parameter name="from"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">the actor that the focus is coming from</doc>
              <type name="Clutter.Actor" c:type="ClutterActor*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <doc xml:space="preserve">the direction focus is moving in</doc>
              <type name="Gtk.DirectionType" c:type="GtkDirectionType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_accessible_type">
        <callback name="get_accessible_type">
          <return-value transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </return-value>
        </callback>
      </field>
      <field name="get_focus_chain">
        <callback name="get_focus_chain">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">
  @widget's focusable children</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Clutter.Actor"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="widget" transfer-ownership="none">
              <doc xml:space="preserve">An #StWidget</doc>
              <type name="Widget" c:type="StWidget*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function name="describe_actor" c:identifier="st_describe_actor">
      <doc xml:space="preserve">Creates a string describing @actor, for use in debugging. This
includes the class name and actor name (if any), plus if @actor
is an #StWidget, its style class and pseudo class names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the debug name.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="actor" transfer-ownership="none">
          <doc xml:space="preserve">a #ClutterActor</doc>
          <type name="Clutter.Actor" c:type="ClutterActor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_align_factors" c:identifier="st_get_align_factors">
      <doc xml:space="preserve">Converts @x_align and @y_align to #gdouble values.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_align" transfer-ownership="none">
          <doc xml:space="preserve">an #StAlign</doc>
          <type name="Align" c:type="StAlign"/>
        </parameter>
        <parameter name="y_align" transfer-ownership="none">
          <doc xml:space="preserve">an #StAlign</doc>
          <type name="Align" c:type="StAlign"/>
        </parameter>
        <parameter name="x_align_out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">@x_align as a #gdouble</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
        <parameter name="y_align_out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">@y_align as a #gdouble</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_slow_down_factor"
              c:identifier="st_get_slow_down_factor">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the global factor applied to all animation durations</doc>
        <type name="gfloat" c:type="gfloat"/>
      </return-value>
    </function>
    <function name="set_slow_down_factor"
              c:identifier="st_set_slow_down_factor">
      <doc xml:space="preserve">Set a global factor applied to all animation durations</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="factor" transfer-ownership="none">
          <doc xml:space="preserve">new slow-down factor</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
